(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[931],{67279:function(e,t,n){Promise.resolve().then(n.bind(n,93541))},93541:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return n_}});var i=n(57437),r=n(90099),o=n(24076),a=n(56810),s=n(29527),l=n(72079),u=n(51448),d=n(2691),h=n(92046),c=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),p=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),m=class extends l.Tme{get overrideBlinkAmount(){return"block"===this.overrideBlink?0<this.outputWeight?1:0:"blend"===this.overrideBlink?this.outputWeight:0}get overrideLookAtAmount(){return"block"===this.overrideLookAt?0<this.outputWeight?1:0:"blend"===this.overrideLookAt?this.outputWeight:0}get overrideMouthAmount(){return"block"===this.overrideMouth?0<this.outputWeight?1:0:"blend"===this.overrideMouth?this.outputWeight:0}get outputWeight(){return this.isBinary?this.weight>.5?1:0:this.weight}addBind(e){this._binds.push(e)}applyWeight(e){var t;let n=this.outputWeight;n*=null!=(t=null==e?void 0:e.multiplier)?t:1,this.isBinary&&n<1&&(n=0),this._binds.forEach(e=>e.applyWeight(n))}clearAppliedWeight(){this._binds.forEach(e=>e.clearAppliedWeight())}constructor(e){super(),this.weight=0,this.isBinary=!1,this.overrideBlink="none",this.overrideLookAt="none",this.overrideMouth="none",this._binds=[],this.name="VRMExpression_".concat(e),this.expressionName=e,this.type="VRMExpression",this.visible=!1}};function f(e,t,n){var i,r;let o=e.parser.json,a=null==(i=o.nodes)?void 0:i[t];if(null==a)return console.warn("extractPrimitivesInternal: Attempt to use nodes[".concat(t,"] of glTF but the node doesn't exist")),null;let s=a.mesh;if(null==s)return null;let l=null==(r=o.meshes)?void 0:r[s];if(null==l)return console.warn("extractPrimitivesInternal: Attempt to use meshes[".concat(s,"] of glTF but the mesh doesn't exist")),null;let u=l.primitives.length,d=[];return n.traverse(e=>{d.length<u&&e.isMesh&&d.push(e)}),d}function g(e,t){return p(this,null,function*(){let n=yield e.parser.getDependency("node",t);return f(e,t,n)})}function _(e){return p(this,null,function*(){let t=yield e.parser.getDependencies("node"),n=new Map;return t.forEach((t,i)=>{let r=f(e,i,t);null!=r&&n.set(i,r)}),n})}var v={Aa:"aa",Ih:"ih",Ou:"ou",Ee:"ee",Oh:"oh",Blink:"blink",Happy:"happy",Angry:"angry",Sad:"sad",Relaxed:"relaxed",LookUp:"lookUp",Surprised:"surprised",LookDown:"lookDown",LookLeft:"lookLeft",LookRight:"lookRight",BlinkLeft:"blinkLeft",BlinkRight:"blinkRight",Neutral:"neutral"};function x(e){return Math.max(Math.min(e,1),0)}var M=class e{get expressions(){return this._expressions.concat()}get expressionMap(){return Object.assign({},this._expressionMap)}get presetExpressionMap(){let e={},t=new Set(Object.values(v));return Object.entries(this._expressionMap).forEach(n=>{let[i,r]=n;t.has(i)&&(e[i]=r)}),e}get customExpressionMap(){let e={},t=new Set(Object.values(v));return Object.entries(this._expressionMap).forEach(n=>{let[i,r]=n;t.has(i)||(e[i]=r)}),e}copy(e){return this._expressions.concat().forEach(e=>{this.unregisterExpression(e)}),e._expressions.forEach(e=>{this.registerExpression(e)}),this.blinkExpressionNames=e.blinkExpressionNames.concat(),this.lookAtExpressionNames=e.lookAtExpressionNames.concat(),this.mouthExpressionNames=e.mouthExpressionNames.concat(),this}clone(){return new e().copy(this)}getExpression(e){var t;return null!=(t=this._expressionMap[e])?t:null}registerExpression(e){this._expressions.push(e),this._expressionMap[e.expressionName]=e}unregisterExpression(e){let t=this._expressions.indexOf(e);-1===t&&console.warn("VRMExpressionManager: The specified expressions is not registered"),this._expressions.splice(t,1),delete this._expressionMap[e.expressionName]}getValue(e){var t;let n=this.getExpression(e);return null!=(t=null==n?void 0:n.weight)?t:null}setValue(e,t){let n=this.getExpression(e);n&&(n.weight=x(t))}resetValues(){this._expressions.forEach(e=>{e.weight=0})}getExpressionTrackName(e){let t=this.getExpression(e);return t?"".concat(t.name,".weight"):null}update(){let e=this._calculateWeightMultipliers();this._expressions.forEach(e=>{e.clearAppliedWeight()}),this._expressions.forEach(t=>{let n=1,i=t.expressionName;-1!==this.blinkExpressionNames.indexOf(i)&&(n*=e.blink),-1!==this.lookAtExpressionNames.indexOf(i)&&(n*=e.lookAt),-1!==this.mouthExpressionNames.indexOf(i)&&(n*=e.mouth),t.applyWeight({multiplier:n})})}_calculateWeightMultipliers(){let e=1,t=1,n=1;return this._expressions.forEach(i=>{e-=i.overrideBlinkAmount,t-=i.overrideLookAtAmount,n-=i.overrideMouthAmount}),{blink:e=Math.max(0,e),lookAt:t=Math.max(0,t),mouth:n=Math.max(0,n)}}constructor(){this.blinkExpressionNames=["blink","blinkLeft","blinkRight"],this.lookAtExpressionNames=["lookLeft","lookRight","lookUp","lookDown"],this.mouthExpressionNames=["aa","ee","ih","oh","ou"],this._expressions=[],this._expressionMap={}}},y={_Color:"color",_EmissionColor:"emissionColor",_ShadeColor:"shadeColor",_RimColor:"rimColor",_OutlineColor:"outlineColor"},w=new l.Ilk,T=class e{applyWeight(e){let{color:t,alpha:n}=this._state;if(null!=t){let{propertyName:n,deltaValue:i}=t,r=this.material[n];null!=r&&r.add(w.copy(i).multiplyScalar(e))}if(null!=n){let{propertyName:t,deltaValue:i}=n;null!=this.material[t]&&(this.material[t]+=i*e)}}clearAppliedWeight(){let{color:e,alpha:t}=this._state;if(null!=e){let{propertyName:t,initialValue:n}=e,i=this.material[t];null!=i&&i.copy(n)}if(null!=t){let{propertyName:e,initialValue:n}=t;null!=this.material[e]&&(this.material[e]=n)}}_initColorBindState(){var e,t,n;let{material:i,type:r,targetValue:o}=this,a=this._getPropertyNameMap(),s=null!=(t=null==(e=null==a?void 0:a[r])?void 0:e[0])?t:null;if(null==s)return console.warn("Tried to add a material color bind to the material ".concat(null!=(n=i.name)?n:"(no name)",", the type ").concat(r," but the material or the type is not supported.")),null;let u=i[s].clone(),d=new l.Ilk(o.r-u.r,o.g-u.g,o.b-u.b);return{propertyName:s,initialValue:u,deltaValue:d}}_initAlphaBindState(){var e,t,n;let{material:i,type:r,targetAlpha:o}=this,a=this._getPropertyNameMap(),s=null!=(t=null==(e=null==a?void 0:a[r])?void 0:e[1])?t:null;if(null==s&&1!==o)return console.warn("Tried to add a material alpha bind to the material ".concat(null!=(n=i.name)?n:"(no name)",", the type ").concat(r," but the material or the type does not support alpha.")),null;if(null==s)return null;let l=i[s];return{propertyName:s,initialValue:l,deltaValue:o-l}}_getPropertyNameMap(){var t,n;return null!=(n=null==(t=Object.entries(e._propertyNameMapMap).find(e=>{let[t]=e;return!0===this.material[t]}))?void 0:t[1])?n:null}constructor({material:e,type:t,targetValue:n,targetAlpha:i}){this.material=e,this.type=t,this.targetValue=n,this.targetAlpha=null!=i?i:1;let r=this._initColorBindState(),o=this._initAlphaBindState();this._state={color:r,alpha:o}}};T._propertyNameMapMap={isMeshStandardMaterial:{color:["color","opacity"],emissionColor:["emissive",null]},isMeshBasicMaterial:{color:["color","opacity"]},isMToonMaterial:{color:["color","opacity"],emissionColor:["emissive",null],outlineColor:["outlineColorFactor",null],matcapColor:["matcapFactor",null],rimColor:["parametricRimColorFactor",null],shadeColor:["shadeColorFactor",null]}};var P=class{applyWeight(e){this.primitives.forEach(t=>{var n;(null==(n=t.morphTargetInfluences)?void 0:n[this.index])!=null&&(t.morphTargetInfluences[this.index]+=this.weight*e)})}clearAppliedWeight(){this.primitives.forEach(e=>{var t;(null==(t=e.morphTargetInfluences)?void 0:t[this.index])!=null&&(e.morphTargetInfluences[this.index]=0)})}constructor({primitives:e,index:t,weight:n}){this.primitives=e,this.index=t,this.weight=n}},E=new l.FM8,R=class e{applyWeight(e){this._properties.forEach(t=>{let n=this.material[t.name];void 0!==n&&(n.offset.add(E.copy(t.deltaOffset).multiplyScalar(e)),n.repeat.add(E.copy(t.deltaScale).multiplyScalar(e)))})}clearAppliedWeight(){this._properties.forEach(e=>{let t=this.material[e.name];void 0!==t&&(t.offset.copy(e.initialOffset),t.repeat.copy(e.initialScale))})}constructor({material:t,scale:n,offset:i}){var r,o;this.material=t,this.scale=n,this.offset=i;let a=null==(r=Object.entries(e._propertyNamesMap).find(e=>{let[n]=e;return!0===t[n]}))?void 0:r[1];null==a?(console.warn("Tried to add a texture transform bind to the material ".concat(null!=(o=t.name)?o:"(no name)"," but the material is not supported.")),this._properties=[]):(this._properties=[],a.forEach(e=>{var r;let o=null==(r=t[e])?void 0:r.clone();if(!o)return null;t[e]=o;let a=o.offset.clone(),s=o.repeat.clone(),l=i.clone().sub(a),u=n.clone().sub(s);this._properties.push({name:e,initialOffset:a,deltaOffset:l,initialScale:s,deltaScale:u})}))}};R._propertyNamesMap={isMeshStandardMaterial:["map","emissiveMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","alphaMap"],isMeshBasicMaterial:["map","specularMap","alphaMap"],isMToonMaterial:["map","normalMap","emissiveMap","shadeMultiplyTexture","rimMultiplyTexture","outlineWidthMultiplyTexture","uvAnimationMaskTexture"]};var S=new Set(["1.0","1.0-beta"]),A=class e{get name(){return"VRMExpressionLoaderPlugin"}afterRoot(e){return p(this,null,function*(){e.userData.vrmExpressionManager=yield this._import(e)})}_import(e){return p(this,null,function*(){return(yield this._v1Import(e))||(yield this._v0Import(e))||null})}_v1Import(e){return p(this,null,function*(){var t,n;let i=this.parser.json;if(!((null==(t=i.extensionsUsed)?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;let r=null==(n=i.extensions)?void 0:n.VRMC_vrm;if(!r)return null;let o=r.specVersion;if(!S.has(o))return console.warn('VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "'.concat(o,'"')),null;let a=r.expressions;if(!a)return null;let s=new Set(Object.values(v)),u=new Map;null!=a.preset&&Object.entries(a.preset).forEach(e=>{let[t,n]=e;if(null!=n){if(!s.has(t)){console.warn('VRMExpressionLoaderPlugin: Unknown preset name "'.concat(t,'" detected. Ignoring the expression'));return}u.set(t,n)}}),null!=a.custom&&Object.entries(a.custom).forEach(e=>{let[t,n]=e;if(s.has(t)){console.warn('VRMExpressionLoaderPlugin: Custom expression cannot have preset name "'.concat(t,'". Ignoring the expression'));return}u.set(t,n)});let d=new M;return yield Promise.all(Array.from(u.entries()).map(t=>p(this,[t],function*(t){var n,i,r,o,a,s,u;let[h,c]=t,f=new m(h);if(e.scene.add(f),f.isBinary=null!=(n=c.isBinary)&&n,f.overrideBlink=null!=(i=c.overrideBlink)?i:"none",f.overrideLookAt=null!=(r=c.overrideLookAt)?r:"none",f.overrideMouth=null!=(o=c.overrideMouth)?o:"none",null==(a=c.morphTargetBinds)||a.forEach(t=>p(this,null,function*(){var n;if(void 0===t.node||void 0===t.index)return;let i=yield g(e,t.node),r=t.index;if(!i.every(e=>Array.isArray(e.morphTargetInfluences)&&r<e.morphTargetInfluences.length)){console.warn("VRMExpressionLoaderPlugin: ".concat(c.name," attempts to index morph #").concat(r," but not found."));return}f.addBind(new P({primitives:i,index:r,weight:null!=(n=t.weight)?n:1}))})),c.materialColorBinds||c.textureTransformBinds){let t=[];e.scene.traverse(e=>{let n=e.material;n&&(Array.isArray(n)?t.push(...n):t.push(n))}),null==(s=c.materialColorBinds)||s.forEach(e=>p(this,null,function*(){t.filter(t=>{var n;let i=null==(n=this.parser.associations.get(t))?void 0:n.materials;return e.material===i}).forEach(t=>{f.addBind(new T({material:t,type:e.type,targetValue:new l.Ilk().fromArray(e.targetValue),targetAlpha:e.targetValue[3]}))})})),null==(u=c.textureTransformBinds)||u.forEach(e=>p(this,null,function*(){t.filter(t=>{var n;let i=null==(n=this.parser.associations.get(t))?void 0:n.materials;return e.material===i}).forEach(t=>{var n,i;f.addBind(new R({material:t,offset:new l.FM8().fromArray(null!=(n=e.offset)?n:[0,0]),scale:new l.FM8().fromArray(null!=(i=e.scale)?i:[1,1])}))})}))}d.registerExpression(f)}))),d})}_v0Import(t){return p(this,null,function*(){var n;let i=this.parser.json,r=null==(n=i.extensions)?void 0:n.VRM;if(!r)return null;let o=r.blendShapeMaster;if(!o)return null;let a=new M,s=o.blendShapeGroups;if(!s)return a;let u=new Set;return yield Promise.all(s.map(n=>p(this,null,function*(){var r;let o=n.presetName,s=null!=o&&e.v0v1PresetNameMap[o]||null,d=null!=s?s:n.name;if(null==d){console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");return}if(u.has(d)){console.warn("VRMExpressionLoaderPlugin: An expression preset ".concat(o," has duplicated entries. Ignoring the expression"));return}u.add(d);let h=new m(d);t.scene.add(h),h.isBinary=null!=(r=n.isBinary)&&r,n.binds&&n.binds.forEach(e=>p(this,null,function*(){var r;if(void 0===e.mesh||void 0===e.index)return;let o=[];null==(r=i.nodes)||r.forEach((t,n)=>{t.mesh===e.mesh&&o.push(n)});let a=e.index;yield Promise.all(o.map(i=>p(this,null,function*(){var r;let o=yield g(t,i);if(!o.every(e=>Array.isArray(e.morphTargetInfluences)&&a<e.morphTargetInfluences.length)){console.warn("VRMExpressionLoaderPlugin: ".concat(n.name," attempts to index ").concat(a,"th morph but not found."));return}h.addBind(new P({primitives:o,index:a,weight:.01*(null!=(r=e.weight)?r:100)}))})))}));let c=n.materialValues;c&&0!==c.length&&c.forEach(e=>{if(void 0===e.materialName||void 0===e.propertyName||void 0===e.targetValue)return;let n=[];t.scene.traverse(t=>{if(t.material){let i=t.material;Array.isArray(i)?n.push(...i.filter(t=>(t.name===e.materialName||t.name===e.materialName+" (Outline)")&&-1===n.indexOf(t))):i.name===e.materialName&&-1===n.indexOf(i)&&n.push(i)}});let i=e.propertyName;n.forEach(t=>{if("_MainTex_ST"===i){let n=new l.FM8(e.targetValue[0],e.targetValue[1]),i=new l.FM8(e.targetValue[2],e.targetValue[3]);i.y=1-i.y-n.y,h.addBind(new R({material:t,scale:n,offset:i}));return}let n=y[i];if(n){h.addBind(new T({material:t,type:n,targetValue:new l.Ilk().fromArray(e.targetValue),targetAlpha:e.targetValue[3]}));return}console.warn(i+" is not supported")})}),a.registerExpression(h)}))),a})}constructor(e){this.parser=e}};A.v0v1PresetNameMap={a:"aa",e:"ee",i:"ih",o:"oh",u:"ou",blink:"blink",joy:"happy",angry:"angry",sorrow:"sad",fun:"relaxed",lookup:"lookUp",lookdown:"lookDown",lookleft:"lookLeft",lookright:"lookRight",blink_l:"blinkLeft",blink_r:"blinkRight",neutral:"neutral"};var b=class e{copy(e){if(this.humanoid!==e.humanoid)throw Error("VRMFirstPerson: humanoid must be same in order to copy");return this.meshAnnotations=e.meshAnnotations.map(e=>({meshes:e.meshes.concat(),type:e.type})),this}clone(){return new e(this.humanoid,this.meshAnnotations).copy(this)}get firstPersonOnlyLayer(){return this._firstPersonOnlyLayer}get thirdPersonOnlyLayer(){return this._thirdPersonOnlyLayer}setup(){let{firstPersonOnlyLayer:t=e.DEFAULT_FIRSTPERSON_ONLY_LAYER,thirdPersonOnlyLayer:n=e.DEFAULT_THIRDPERSON_ONLY_LAYER}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._initializedLayers||(this._firstPersonOnlyLayer=t,this._thirdPersonOnlyLayer=n,this.meshAnnotations.forEach(e=>{e.meshes.forEach(t=>{"firstPersonOnly"===e.type?(t.layers.set(this._firstPersonOnlyLayer),t.traverse(e=>e.layers.set(this._firstPersonOnlyLayer))):"thirdPersonOnly"===e.type?(t.layers.set(this._thirdPersonOnlyLayer),t.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer))):"auto"===e.type&&this._createHeadlessModel(t)})}),this._initializedLayers=!0)}_excludeTriangles(e,t,n,i){let r=0;if(null!=t&&t.length>0)for(let o=0;o<e.length;o+=3){let a=e[o],s=e[o+1],l=e[o+2],u=t[a],d=n[a];if(u[0]>0&&i.includes(d[0])||u[1]>0&&i.includes(d[1])||u[2]>0&&i.includes(d[2])||u[3]>0&&i.includes(d[3]))continue;let h=t[s],c=n[s];if(h[0]>0&&i.includes(c[0])||h[1]>0&&i.includes(c[1])||h[2]>0&&i.includes(c[2])||h[3]>0&&i.includes(c[3]))continue;let p=t[l],m=n[l];p[0]>0&&i.includes(m[0])||p[1]>0&&i.includes(m[1])||p[2]>0&&i.includes(m[2])||p[3]>0&&i.includes(m[3])||(e[r++]=a,e[r++]=s,e[r++]=l)}return r}_createErasedMesh(e,t){let n=new l.TUv(e.geometry.clone(),e.material);n.name="".concat(e.name,"(erase)"),n.frustumCulled=e.frustumCulled,n.layers.set(this._firstPersonOnlyLayer);let i=n.geometry,r=i.getAttribute("skinIndex"),o=r instanceof l.ylh?[]:r.array,a=[];for(let e=0;e<o.length;e+=4)a.push([o[e],o[e+1],o[e+2],o[e+3]]);let s=i.getAttribute("skinWeight"),u=s instanceof l.ylh?[]:s.array,d=[];for(let e=0;e<u.length;e+=4)d.push([u[e],u[e+1],u[e+2],u[e+3]]);let h=i.getIndex();if(!h)throw Error("The geometry doesn't have an index buffer");let c=Array.from(h.array),p=this._excludeTriangles(c,d,a,t),m=[];for(let e=0;e<p;e++)m[e]=c[e];return i.setIndex(m),e.onBeforeRender&&(n.onBeforeRender=e.onBeforeRender),n.bind(new l.OdW(e.skeleton.bones,e.skeleton.boneInverses),new l.yGw),n}_createHeadlessModelForSkinnedMesh(e,t){let n=[];if(t.skeleton.bones.forEach((e,t)=>{this._isEraseTarget(e)&&n.push(t)}),!n.length){t.layers.enable(this._thirdPersonOnlyLayer),t.layers.enable(this._firstPersonOnlyLayer);return}t.layers.set(this._thirdPersonOnlyLayer);let i=this._createErasedMesh(t,n);e.add(i)}_createHeadlessModel(e){if("Group"===e.type){if(e.layers.set(this._thirdPersonOnlyLayer),this._isEraseTarget(e))e.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer));else{let t=new l.ZAu;t.name="_headless_".concat(e.name),t.layers.set(this._firstPersonOnlyLayer),e.parent.add(t),e.children.filter(e=>"SkinnedMesh"===e.type).forEach(e=>{this._createHeadlessModelForSkinnedMesh(t,e)})}}else"SkinnedMesh"===e.type?this._createHeadlessModelForSkinnedMesh(e.parent,e):this._isEraseTarget(e)&&(e.layers.set(this._thirdPersonOnlyLayer),e.traverse(e=>e.layers.set(this._thirdPersonOnlyLayer)))}_isEraseTarget(e){return e===this.humanoid.getRawBoneNode("head")||!!e.parent&&this._isEraseTarget(e.parent)}constructor(t,n){this._firstPersonOnlyLayer=e.DEFAULT_FIRSTPERSON_ONLY_LAYER,this._thirdPersonOnlyLayer=e.DEFAULT_THIRDPERSON_ONLY_LAYER,this._initializedLayers=!1,this.humanoid=t,this.meshAnnotations=n}};b.DEFAULT_FIRSTPERSON_ONLY_LAYER=9,b.DEFAULT_THIRDPERSON_ONLY_LAYER=10;var L=new Set(["1.0","1.0-beta"]),I=class{get name(){return"VRMFirstPersonLoaderPlugin"}afterRoot(e){return p(this,null,function*(){let t=e.userData.vrmHumanoid;if(null!==t){if(void 0===t)throw Error("VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");e.userData.vrmFirstPerson=yield this._import(e,t)}})}_import(e,t){return p(this,null,function*(){return null==t?null:(yield this._v1Import(e,t))||(yield this._v0Import(e,t))||null})}_v1Import(e,t){return p(this,null,function*(){var n,i;let r=this.parser.json;if(!((null==(n=r.extensionsUsed)?void 0:n.indexOf("VRMC_vrm"))!==-1))return null;let o=null==(i=r.extensions)?void 0:i.VRMC_vrm;if(!o)return null;let a=o.specVersion;if(!L.has(a))return console.warn('VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "'.concat(a,'"')),null;let s=o.firstPerson,l=[];return Array.from((yield _(e)).entries()).forEach(e=>{var t,n;let[i,r]=e,o=null==(t=null==s?void 0:s.meshAnnotations)?void 0:t.find(e=>e.node===i);l.push({meshes:r,type:null!=(n=null==o?void 0:o.type)?n:"auto"})}),new b(t,l)})}_v0Import(e,t){return p(this,null,function*(){var n;let i=this.parser.json,r=null==(n=i.extensions)?void 0:n.VRM;if(!r)return null;let o=r.firstPerson;if(!o)return null;let a=[];return Array.from((yield _(e)).entries()).forEach(e=>{let[t,n]=e,r=i.nodes[t],s=o.meshAnnotations?o.meshAnnotations.find(e=>e.mesh===r.mesh):void 0;a.push({meshes:n,type:this._convertV0FlagToV1Type(null==s?void 0:s.firstPersonFlag)})}),new b(t,a)})}_convertV0FlagToV1Type(e){return"FirstPersonOnly"===e?"firstPersonOnly":"ThirdPersonOnly"===e?"thirdPersonOnly":"Both"===e?"both":"auto"}constructor(e){this.parser=e}},C=new l.Pa4,N=new l.Pa4,U=new l._fP,O=class extends l.ZAu{dispose(){Array.from(this._boneAxesMap.values()).forEach(e=>{e.geometry.dispose(),e.material.dispose()})}updateMatrixWorld(e){Array.from(this._boneAxesMap.entries()).forEach(e=>{let[t,n]=e;t.node.updateWorldMatrix(!0,!1),t.node.matrixWorld.decompose(C,U,N);let i=C.set(.1,.1,.1).divide(N);n.matrix.copy(t.node.matrixWorld).scale(i)}),super.updateMatrixWorld(e)}constructor(e){super(),this.vrmHumanoid=e,this._boneAxesMap=new Map,Object.values(e.humanBones).forEach(e=>{let t=new l.y8_(1);t.matrixAutoUpdate=!1,t.material.depthTest=!1,t.material.depthWrite=!1,this.add(t),this._boneAxesMap.set(e,t)})}},F=["hips","spine","chest","upperChest","neck","head","leftEye","rightEye","jaw","leftUpperLeg","leftLowerLeg","leftFoot","leftToes","rightUpperLeg","rightLowerLeg","rightFoot","rightToes","leftShoulder","leftUpperArm","leftLowerArm","leftHand","rightShoulder","rightUpperArm","rightLowerArm","rightHand","leftThumbMetacarpal","leftThumbProximal","leftThumbDistal","leftIndexProximal","leftIndexIntermediate","leftIndexDistal","leftMiddleProximal","leftMiddleIntermediate","leftMiddleDistal","leftRingProximal","leftRingIntermediate","leftRingDistal","leftLittleProximal","leftLittleIntermediate","leftLittleDistal","rightThumbMetacarpal","rightThumbProximal","rightThumbDistal","rightIndexProximal","rightIndexIntermediate","rightIndexDistal","rightMiddleProximal","rightMiddleIntermediate","rightMiddleDistal","rightRingProximal","rightRingIntermediate","rightRingDistal","rightLittleProximal","rightLittleIntermediate","rightLittleDistal"],D={hips:null,spine:"hips",chest:"spine",upperChest:"chest",neck:"upperChest",head:"neck",leftEye:"head",rightEye:"head",jaw:"head",leftUpperLeg:"hips",leftLowerLeg:"leftUpperLeg",leftFoot:"leftLowerLeg",leftToes:"leftFoot",rightUpperLeg:"hips",rightLowerLeg:"rightUpperLeg",rightFoot:"rightLowerLeg",rightToes:"rightFoot",leftShoulder:"upperChest",leftUpperArm:"leftShoulder",leftLowerArm:"leftUpperArm",leftHand:"leftLowerArm",rightShoulder:"upperChest",rightUpperArm:"rightShoulder",rightLowerArm:"rightUpperArm",rightHand:"rightLowerArm",leftThumbMetacarpal:"leftHand",leftThumbProximal:"leftThumbMetacarpal",leftThumbDistal:"leftThumbProximal",leftIndexProximal:"leftHand",leftIndexIntermediate:"leftIndexProximal",leftIndexDistal:"leftIndexIntermediate",leftMiddleProximal:"leftHand",leftMiddleIntermediate:"leftMiddleProximal",leftMiddleDistal:"leftMiddleIntermediate",leftRingProximal:"leftHand",leftRingIntermediate:"leftRingProximal",leftRingDistal:"leftRingIntermediate",leftLittleProximal:"leftHand",leftLittleIntermediate:"leftLittleProximal",leftLittleDistal:"leftLittleIntermediate",rightThumbMetacarpal:"rightHand",rightThumbProximal:"rightThumbMetacarpal",rightThumbDistal:"rightThumbProximal",rightIndexProximal:"rightHand",rightIndexIntermediate:"rightIndexProximal",rightIndexDistal:"rightIndexIntermediate",rightMiddleProximal:"rightHand",rightMiddleIntermediate:"rightMiddleProximal",rightMiddleDistal:"rightMiddleIntermediate",rightRingProximal:"rightHand",rightRingIntermediate:"rightRingProximal",rightRingDistal:"rightRingIntermediate",rightLittleProximal:"rightHand",rightLittleIntermediate:"rightLittleProximal",rightLittleDistal:"rightLittleIntermediate"};function V(e){return e.invert?e.invert():e.inverse(),e}var H=new l.Pa4,B=new l._fP,j=class{getAbsolutePose(){let e={};return Object.keys(this.humanBones).forEach(t=>{let n=this.getBoneNode(t);n&&(H.copy(n.position),B.copy(n.quaternion),e[t]={position:H.toArray(),rotation:B.toArray()})}),e}getPose(){let e={};return Object.keys(this.humanBones).forEach(t=>{let n=this.getBoneNode(t);if(!n)return;H.set(0,0,0),B.identity();let i=this.restPose[t];null!=i&&i.position&&H.fromArray(i.position).negate(),null!=i&&i.rotation&&V(B.fromArray(i.rotation)),H.add(n.position),B.premultiply(n.quaternion),e[t]={position:H.toArray(),rotation:B.toArray()}}),e}setPose(e){Object.entries(e).forEach(e=>{let[t,n]=e,i=this.getBoneNode(t);if(!i)return;let r=this.restPose[t];r&&(null!=n&&n.position&&(i.position.fromArray(n.position),r.position&&i.position.add(H.fromArray(r.position))),null!=n&&n.rotation&&(i.quaternion.fromArray(n.rotation),r.rotation&&i.quaternion.multiply(B.fromArray(r.rotation))))})}resetPose(){Object.entries(this.restPose).forEach(e=>{let[t,n]=e,i=this.getBoneNode(t);i&&(null!=n&&n.position&&i.position.fromArray(n.position),null!=n&&n.rotation&&i.quaternion.fromArray(n.rotation))})}getBone(e){var t;return null!=(t=this.humanBones[e])?t:void 0}getBoneNode(e){var t,n;return null!=(n=null==(t=this.humanBones[e])?void 0:t.node)?n:null}constructor(e){this.humanBones=e,this.restPose=this.getAbsolutePose()}},k=new l.Pa4,W=new l._fP,z=new l.Pa4,G=class e extends j{static _setupTransforms(e){let t=new l.Tme;t.name="VRMHumanoidRig";let n={},i={},r={},o={};F.forEach(t=>{var a;let s=e.getBoneNode(t);if(s){let e=new l.Pa4,u=new l._fP;s.updateWorldMatrix(!0,!1),s.matrixWorld.decompose(e,u,k),n[t]=e,i[t]=u,r[t]=s.quaternion.clone();let d=new l._fP;null==(a=s.parent)||a.matrixWorld.decompose(k,d,k),o[t]=d}});let a={};return F.forEach(i=>{var r;let o=e.getBoneNode(i);if(o){let e=n[i],s=i,u;for(;null==u&&null!=(s=D[s]);)u=n[s];let d=new l.Tme;d.name="Normalized_"+o.name,(s?null==(r=a[s])?void 0:r.node:t).add(d),d.position.copy(e),u&&d.position.sub(u),a[i]={node:d}}}),{rigBones:a,root:t,parentWorldRotations:o,boneRotations:r}}update(){F.forEach(e=>{let t=this.original.getBoneNode(e);if(null!=t){let n=this.getBoneNode(e),i=this._parentWorldRotations[e],r=W.copy(i).invert(),o=this._boneRotations[e];if(t.quaternion.copy(n.quaternion).multiply(i).premultiply(r).multiply(o),"hips"===e){let e=n.getWorldPosition(z);t.parent.updateWorldMatrix(!0,!1);let i=t.parent.matrixWorld,r=e.applyMatrix4(i.invert());t.position.copy(r)}}})}constructor(t){let{rigBones:n,root:i,parentWorldRotations:r,boneRotations:o}=e._setupTransforms(t);super(n),this.original=t,this.root=i,this._parentWorldRotations=r,this._boneRotations=o}},X=class e{get restPose(){return console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead."),this.rawRestPose}get rawRestPose(){return this._rawHumanBones.restPose}get normalizedRestPose(){return this._normalizedHumanBones.restPose}get humanBones(){return this._rawHumanBones.humanBones}get rawHumanBones(){return this._rawHumanBones.humanBones}get normalizedHumanBones(){return this._normalizedHumanBones.humanBones}get normalizedHumanBonesRoot(){return this._normalizedHumanBones.root}copy(e){return this.autoUpdateHumanBones=e.autoUpdateHumanBones,this._rawHumanBones=new j(e.humanBones),this._normalizedHumanBones=new G(this._rawHumanBones),this}clone(){return new e(this.humanBones,{autoUpdateHumanBones:this.autoUpdateHumanBones}).copy(this)}getAbsolutePose(){return console.warn("VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."),this.getRawAbsolutePose()}getRawAbsolutePose(){return this._rawHumanBones.getAbsolutePose()}getNormalizedAbsolutePose(){return this._normalizedHumanBones.getAbsolutePose()}getPose(){return console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead."),this.getRawPose()}getRawPose(){return this._rawHumanBones.getPose()}getNormalizedPose(){return this._normalizedHumanBones.getPose()}setPose(e){return console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead."),this.setRawPose(e)}setRawPose(e){return this._rawHumanBones.setPose(e)}setNormalizedPose(e){return this._normalizedHumanBones.setPose(e)}resetPose(){return console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead."),this.resetRawPose()}resetRawPose(){return this._rawHumanBones.resetPose()}resetNormalizedPose(){return this._normalizedHumanBones.resetPose()}getBone(e){return console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead."),this.getRawBone(e)}getRawBone(e){return this._rawHumanBones.getBone(e)}getNormalizedBone(e){return this._normalizedHumanBones.getBone(e)}getBoneNode(e){return console.warn("VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."),this.getRawBoneNode(e)}getRawBoneNode(e){return this._rawHumanBones.getBoneNode(e)}getNormalizedBoneNode(e){return this._normalizedHumanBones.getBoneNode(e)}update(){this.autoUpdateHumanBones&&this._normalizedHumanBones.update()}constructor(e,t){var n;this.autoUpdateHumanBones=null==(n=null==t?void 0:t.autoUpdateHumanBones)||n,this._rawHumanBones=new j(e),this._normalizedHumanBones=new G(this._rawHumanBones)}},Y={Hips:"hips",Spine:"spine",Head:"head",LeftUpperLeg:"leftUpperLeg",LeftLowerLeg:"leftLowerLeg",LeftFoot:"leftFoot",RightUpperLeg:"rightUpperLeg",RightLowerLeg:"rightLowerLeg",RightFoot:"rightFoot",LeftUpperArm:"leftUpperArm",LeftLowerArm:"leftLowerArm",LeftHand:"leftHand",RightUpperArm:"rightUpperArm",RightLowerArm:"rightLowerArm",RightHand:"rightHand"},Z=new Set(["1.0","1.0-beta"]),q={leftThumbProximal:"leftThumbMetacarpal",leftThumbIntermediate:"leftThumbProximal",rightThumbProximal:"rightThumbMetacarpal",rightThumbIntermediate:"rightThumbProximal"},Q=class{get name(){return"VRMHumanoidLoaderPlugin"}afterRoot(e){return p(this,null,function*(){e.userData.vrmHumanoid=yield this._import(e)})}_import(e){return p(this,null,function*(){return(yield this._v1Import(e))||(yield this._v0Import(e))||null})}_v1Import(e){return p(this,null,function*(){var t,n;let i=this.parser.json;if(!((null==(t=i.extensionsUsed)?void 0:t.indexOf("VRMC_vrm"))!==-1))return null;let r=null==(n=i.extensions)?void 0:n.VRMC_vrm;if(!r)return null;let o=r.specVersion;if(!Z.has(o))return console.warn('VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "'.concat(o,'"')),null;let a=r.humanoid;if(!a)return null;let s=null!=a.humanBones.leftThumbIntermediate||null!=a.humanBones.rightThumbIntermediate,l={};null!=a.humanBones&&(yield Promise.all(Object.entries(a.humanBones).map(e=>p(this,[e],function*(e){let[t,n]=e,i=t,r=n.node;if(s){let e=q[i];null!=e&&(i=e)}let o=yield this.parser.getDependency("node",r);if(null==o){console.warn("A glTF node bound to the humanoid bone ".concat(i," (index = ").concat(r,") does not exist"));return}l[i]={node:o}}))));let u=new X(this._ensureRequiredBonesExist(l),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(e.scene.add(u.normalizedHumanBonesRoot),this.helperRoot){let e=new O(u);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return u})}_v0Import(e){return p(this,null,function*(){var t;let n=null==(t=this.parser.json.extensions)?void 0:t.VRM;if(!n)return null;let i=n.humanoid;if(!i)return null;let r={};null!=i.humanBones&&(yield Promise.all(i.humanBones.map(e=>p(this,null,function*(){let t=e.bone,n=e.node;if(null==t||null==n)return;let i=yield this.parser.getDependency("node",n);if(null==i){console.warn("A glTF node bound to the humanoid bone ".concat(t," (index = ").concat(n,") does not exist"));return}let o=q[t],a=null!=o?o:t;if(null!=r[a]){console.warn("Multiple bone entries for ".concat(a," detected (index = ").concat(n,"), ignoring duplicated entries."));return}r[a]={node:i}}))));let o=new X(this._ensureRequiredBonesExist(r),{autoUpdateHumanBones:this.autoUpdateHumanBones});if(e.scene.add(o.normalizedHumanBonesRoot),this.helperRoot){let e=new O(o);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return o})}_ensureRequiredBonesExist(e){let t=Object.values(Y).filter(t=>null==e[t]);if(t.length>0)throw Error("VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ".concat(t.join(", ")));return e}constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot,this.autoUpdateHumanBones=null==t?void 0:t.autoUpdateHumanBones}},J=class extends l.u9r{update(){let e=!1;this._currentTheta!==this.theta&&(this._currentTheta=this.theta,e=!0),this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),e&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,0,0,0);for(let e=0;e<64;e++){let t=e/63*this._currentTheta;this._attrPos.setXYZ(e+1,this._currentRadius*Math.sin(t),0,this._currentRadius*Math.cos(t))}this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<63;e++)this._attrIndex.setXYZ(3*e,0,e+1,e+2);this._attrIndex.needsUpdate=!0}constructor(){super(),this._currentTheta=0,this._currentRadius=0,this.theta=0,this.radius=0,this._currentTheta=0,this._currentRadius=0,this._attrPos=new l.TlE(new Float32Array(195),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(189),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},K=class extends l.u9r{update(){let e=!1;this._currentRadius!==this.radius&&(this._currentRadius=this.radius,e=!0),this._currentTail.equals(this.tail)||(this._currentTail.copy(this.tail),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){let t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){let t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}constructor(){super(),this.radius=0,this._currentRadius=0,this.tail=new l.Pa4,this._currentTail=new l.Pa4,this._attrPos=new l.TlE(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},$=new l._fP,ee=new l._fP,et=new l.Pa4,en=new l.Pa4,ei=Math.sqrt(2)/2,er=new l._fP(0,0,-ei,ei),eo=new l.Pa4(0,1,0),ea=class extends l.ZAu{dispose(){this._meshYaw.geometry.dispose(),this._meshYaw.material.dispose(),this._meshPitch.geometry.dispose(),this._meshPitch.material.dispose(),this._lineTarget.geometry.dispose(),this._lineTarget.material.dispose()}updateMatrixWorld(e){let t=l.M8C.DEG2RAD*this.vrmLookAt.yaw;this._meshYaw.geometry.theta=t,this._meshYaw.geometry.update();let n=l.M8C.DEG2RAD*this.vrmLookAt.pitch;this._meshPitch.geometry.theta=n,this._meshPitch.geometry.update(),this.vrmLookAt.getLookAtWorldPosition(et),this.vrmLookAt.getLookAtWorldQuaternion($),$.multiply(this.vrmLookAt.getFaceFrontQuaternion(ee)),this._meshYaw.position.copy(et),this._meshYaw.quaternion.copy($),this._meshPitch.position.copy(et),this._meshPitch.quaternion.copy($),this._meshPitch.quaternion.multiply(ee.setFromAxisAngle(eo,t)),this._meshPitch.quaternion.multiply(er);let{target:i,autoUpdate:r}=this.vrmLookAt;null!=i&&r&&(i.getWorldPosition(en).sub(et),this._lineTarget.geometry.tail.copy(en),this._lineTarget.geometry.update(),this._lineTarget.position.copy(et)),super.updateMatrixWorld(e)}constructor(e){super(),this.matrixAutoUpdate=!1,this.vrmLookAt=e;{let e=new J;e.radius=.5;let t=new l.vBJ({color:65280,transparent:!0,opacity:.5,side:l.ehD,depthTest:!1,depthWrite:!1});this._meshPitch=new l.Kj0(e,t),this.add(this._meshPitch)}{let e=new J;e.radius=.5;let t=new l.vBJ({color:16711680,transparent:!0,opacity:.5,side:l.ehD,depthTest:!1,depthWrite:!1});this._meshYaw=new l.Kj0(e,t),this.add(this._meshYaw)}{let e=new K;e.radius=.1;let t=new l.nls({color:16777215,depthTest:!1,depthWrite:!1});this._lineTarget=new l.ejS(e,t),this._lineTarget.frustumCulled=!1,this.add(this._lineTarget)}}},es=new l.Pa4,el=new l.Pa4;function eu(e,t){return e.matrixWorld.decompose(es,t,el),t}function ed(e){return[Math.atan2(-e.z,e.x),Math.atan2(e.y,Math.sqrt(e.x*e.x+e.z*e.z))]}function eh(e){return e-2*Math.PI*Math.round(e/2/Math.PI)}var ec=new l.Pa4(0,0,1),ep=new l.Pa4,em=new l.Pa4,ef=new l.Pa4,eg=new l._fP,e_=new l._fP,ev=new l._fP,ex=new l._fP,eM=new l.USm,ey=class e{get yaw(){return this._yaw}set yaw(e){this._yaw=e,this._needsUpdate=!0}get pitch(){return this._pitch}set pitch(e){this._pitch=e,this._needsUpdate=!0}get euler(){return console.warn("VRMLookAt: euler is deprecated. use getEuler() instead."),this.getEuler(new l.USm)}getEuler(e){return e.set(l.M8C.DEG2RAD*this._pitch,l.M8C.DEG2RAD*this._yaw,0,"YXZ")}copy(e){if(this.humanoid!==e.humanoid)throw Error("VRMLookAt: humanoid must be same in order to copy");return this.offsetFromHeadBone.copy(e.offsetFromHeadBone),this.applier=e.applier,this.autoUpdate=e.autoUpdate,this.target=e.target,this.faceFront.copy(e.faceFront),this}clone(){return new e(this.humanoid,this.applier).copy(this)}reset(){this._yaw=0,this._pitch=0,this._needsUpdate=!0}getLookAtWorldPosition(e){let t=this.humanoid.getRawBoneNode("head");return e.copy(this.offsetFromHeadBone).applyMatrix4(t.matrixWorld)}getLookAtWorldQuaternion(e){return eu(this.humanoid.getRawBoneNode("head"),e)}getFaceFrontQuaternion(e){if(.01>this.faceFront.distanceToSquared(ec))return e.copy(this._restHeadWorldQuaternion).invert();let[t,n]=ed(this.faceFront);return eM.set(0,.5*Math.PI+t,n,"YZX"),e.setFromEuler(eM).premultiply(ex.copy(this._restHeadWorldQuaternion).invert())}getLookAtWorldDirection(e){return this.getLookAtWorldQuaternion(e_),this.getFaceFrontQuaternion(ev),e.copy(ec).applyQuaternion(e_).applyQuaternion(ev).applyEuler(this.getEuler(eM))}lookAt(e){let t=eg.copy(this._restHeadWorldQuaternion).multiply(V(this.getLookAtWorldQuaternion(e_))),n=this.getLookAtWorldPosition(em),i=ef.copy(e).sub(n).applyQuaternion(t).normalize(),[r,o]=ed(this.faceFront),[a,s]=ed(i),u=eh(a-r),d=eh(o-s);this._yaw=l.M8C.RAD2DEG*u,this._pitch=l.M8C.RAD2DEG*d,this._needsUpdate=!0}update(e){null!=this.target&&this.autoUpdate&&this.lookAt(this.target.getWorldPosition(ep)),this._needsUpdate&&(this._needsUpdate=!1,this.applier.applyYawPitch(this._yaw,this._pitch))}constructor(e,t){this.offsetFromHeadBone=new l.Pa4,this.autoUpdate=!0,this.faceFront=new l.Pa4(0,0,1),this.humanoid=e,this.applier=t,this._yaw=0,this._pitch=0,this._needsUpdate=!0,this._restHeadWorldQuaternion=this.getLookAtWorldQuaternion(new l._fP)}};ey.EULER_ORDER="YXZ";var ew=new l.Pa4(0,0,1),eT=new l._fP,eP=new l._fP,eE=new l.USm(0,0,0,"YXZ"),eR=class{applyYawPitch(e,t){let n=this.humanoid.getRawBoneNode("leftEye"),i=this.humanoid.getRawBoneNode("rightEye"),r=this.humanoid.getNormalizedBoneNode("leftEye"),o=this.humanoid.getNormalizedBoneNode("rightEye");n&&(t<0?eE.x=-l.M8C.DEG2RAD*this.rangeMapVerticalDown.map(-t):eE.x=l.M8C.DEG2RAD*this.rangeMapVerticalUp.map(t),e<0?eE.y=-l.M8C.DEG2RAD*this.rangeMapHorizontalInner.map(-e):eE.y=l.M8C.DEG2RAD*this.rangeMapHorizontalOuter.map(e),eT.setFromEuler(eE),this._getWorldFaceFrontQuat(eP),r.quaternion.copy(eP).multiply(eT).multiply(eP.invert()),eT.copy(this._restLeftEyeParentWorldQuat),n.quaternion.copy(r.quaternion).multiply(eT).premultiply(eT.invert()).multiply(this._restQuatLeftEye)),i&&(t<0?eE.x=-l.M8C.DEG2RAD*this.rangeMapVerticalDown.map(-t):eE.x=l.M8C.DEG2RAD*this.rangeMapVerticalUp.map(t),e<0?eE.y=-l.M8C.DEG2RAD*this.rangeMapHorizontalOuter.map(-e):eE.y=l.M8C.DEG2RAD*this.rangeMapHorizontalInner.map(e),eT.setFromEuler(eE),this._getWorldFaceFrontQuat(eP),o.quaternion.copy(eP).multiply(eT).multiply(eP.invert()),eT.copy(this._restRightEyeParentWorldQuat),i.quaternion.copy(o.quaternion).multiply(eT).premultiply(eT.invert()).multiply(this._restQuatRightEye))}lookAt(e){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");let t=l.M8C.RAD2DEG*e.y,n=l.M8C.RAD2DEG*e.x;this.applyYawPitch(t,n)}_getWorldFaceFrontQuat(e){if(.01>this.faceFront.distanceToSquared(ew))return e.identity();let[t,n]=ed(this.faceFront);return eE.set(0,.5*Math.PI+t,n,"YZX"),e.setFromEuler(eE)}constructor(e,t,n,i,r){this.humanoid=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=n,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=r,this.faceFront=new l.Pa4(0,0,1),this._restQuatLeftEye=new l._fP,this._restQuatRightEye=new l._fP,this._restLeftEyeParentWorldQuat=new l._fP,this._restRightEyeParentWorldQuat=new l._fP;let o=this.humanoid.getRawBoneNode("leftEye"),a=this.humanoid.getRawBoneNode("rightEye");o&&(this._restQuatLeftEye.copy(o.quaternion),eu(o.parent,this._restLeftEyeParentWorldQuat)),a&&(this._restQuatRightEye.copy(a.quaternion),eu(a.parent,this._restRightEyeParentWorldQuat))}};eR.type="bone";var eS=class{applyYawPitch(e,t){t<0?(this.expressions.setValue("lookDown",0),this.expressions.setValue("lookUp",this.rangeMapVerticalUp.map(-t))):(this.expressions.setValue("lookUp",0),this.expressions.setValue("lookDown",this.rangeMapVerticalDown.map(t))),e<0?(this.expressions.setValue("lookLeft",0),this.expressions.setValue("lookRight",this.rangeMapHorizontalOuter.map(-e))):(this.expressions.setValue("lookRight",0),this.expressions.setValue("lookLeft",this.rangeMapHorizontalOuter.map(e)))}lookAt(e){console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");let t=l.M8C.RAD2DEG*e.y,n=l.M8C.RAD2DEG*e.x;this.applyYawPitch(t,n)}constructor(e,t,n,i,r){this.expressions=e,this.rangeMapHorizontalInner=t,this.rangeMapHorizontalOuter=n,this.rangeMapVerticalDown=i,this.rangeMapVerticalUp=r}};eS.type="expression";var eA=class{map(e){return this.outputScale*x(e/this.inputMaxValue)}constructor(e,t){this.inputMaxValue=e,this.outputScale=t}},eb=new Set(["1.0","1.0-beta"]),eL=class{get name(){return"VRMLookAtLoaderPlugin"}afterRoot(e){return p(this,null,function*(){let t=e.userData.vrmHumanoid;if(null===t)return;if(void 0===t)throw Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");let n=e.userData.vrmExpressionManager;if(null!==n){if(void 0===n)throw Error("VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first");e.userData.vrmLookAt=yield this._import(e,t,n)}})}_import(e,t,n){return p(this,null,function*(){return null==t||null==n?null:(yield this._v1Import(e,t,n))||(yield this._v0Import(e,t,n))||null})}_v1Import(e,t,n){return p(this,null,function*(){var e,i,r;let o=this.parser.json;if(!((null==(e=o.extensionsUsed)?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;let a=null==(i=o.extensions)?void 0:i.VRMC_vrm;if(!a)return null;let s=a.specVersion;if(!eb.has(s))return console.warn('VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "'.concat(s,'"')),null;let l=a.lookAt;if(!l)return null;let u="expression"===l.type?1:10,d=this._v1ImportRangeMap(l.rangeMapHorizontalInner,u),h=this._v1ImportRangeMap(l.rangeMapHorizontalOuter,u),c=this._v1ImportRangeMap(l.rangeMapVerticalDown,u),p=this._v1ImportRangeMap(l.rangeMapVerticalUp,u),m;m="expression"===l.type?new eS(n,d,h,c,p):new eR(t,d,h,c,p);let f=this._importLookAt(t,m);return f.offsetFromHeadBone.fromArray(null!=(r=l.offsetFromHeadBone)?r:[0,.06,0]),f})}_v1ImportRangeMap(e,t){var n,i;let r=null!=(n=null==e?void 0:e.inputMaxValue)?n:90,o=null!=(i=null==e?void 0:e.outputScale)?i:t;return r<.01&&(console.warn("VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"),r=.01),new eA(r,o)}_v0Import(e,t,n){return p(this,null,function*(){var e,i,r,o;let a=null==(e=this.parser.json.extensions)?void 0:e.VRM;if(!a)return null;let s=a.firstPerson;if(!s)return null;let l="BlendShape"===s.lookAtTypeName?1:10,u=this._v0ImportDegreeMap(s.lookAtHorizontalInner,l),d=this._v0ImportDegreeMap(s.lookAtHorizontalOuter,l),h=this._v0ImportDegreeMap(s.lookAtVerticalDown,l),c=this._v0ImportDegreeMap(s.lookAtVerticalUp,l),p;p="BlendShape"===s.lookAtTypeName?new eS(n,u,d,h,c):new eR(t,u,d,h,c);let m=this._importLookAt(t,p);return s.firstPersonBoneOffset?m.offsetFromHeadBone.set(null!=(i=s.firstPersonBoneOffset.x)?i:0,null!=(r=s.firstPersonBoneOffset.y)?r:.06,-(null!=(o=s.firstPersonBoneOffset.z)?o:0)):m.offsetFromHeadBone.set(0,.06,0),m.faceFront.set(0,0,-1),p instanceof eR&&p.faceFront.set(0,0,-1),m})}_v0ImportDegreeMap(e,t){var n,i;"[0,0,0,1,1,1,1,0]"!==JSON.stringify(null==e?void 0:e.curve)&&console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");let r=null!=(n=null==e?void 0:e.xRange)?n:90,o=null!=(i=null==e?void 0:e.yRange)?i:t;return r<.01&&(console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!"),r=.01),new eA(r,o)}_importLookAt(e,t){let n=new ey(e,t);if(this.helperRoot){let e=new ea(n);this.helperRoot.add(e),e.renderOrder=this.helperRoot.renderOrder}return n}constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot}},eI=new Set(["1.0","1.0-beta"]),eC=class{get name(){return"VRMMetaLoaderPlugin"}afterRoot(e){return p(this,null,function*(){e.userData.vrmMeta=yield this._import(e)})}_import(e){return p(this,null,function*(){let t=yield this._v1Import(e);if(null!=t)return t;let n=yield this._v0Import(e);return null!=n?n:null})}_v1Import(e){return p(this,null,function*(){var e,t,n;let i;let r=this.parser.json;if(!((null==(e=r.extensionsUsed)?void 0:e.indexOf("VRMC_vrm"))!==-1))return null;let o=null==(t=r.extensions)?void 0:t.VRMC_vrm;if(null==o)return null;let a=o.specVersion;if(!eI.has(a))return console.warn('VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "'.concat(a,'"')),null;let s=o.meta;if(!s)return null;let l=s.licenseUrl;if(!new Set(this.acceptLicenseUrls).has(l))throw Error('VRMMetaLoaderPlugin: The license url "'.concat(l,'" is not accepted'));return this.needThumbnailImage&&null!=s.thumbnailImage&&(i=null!=(n=yield this._extractGLTFImage(s.thumbnailImage))?n:void 0),{metaVersion:"1",name:s.name,version:s.version,authors:s.authors,copyrightInformation:s.copyrightInformation,contactInformation:s.contactInformation,references:s.references,thirdPartyLicenses:s.thirdPartyLicenses,thumbnailImage:i,licenseUrl:s.licenseUrl,avatarPermission:s.avatarPermission,allowExcessivelyViolentUsage:s.allowExcessivelyViolentUsage,allowExcessivelySexualUsage:s.allowExcessivelySexualUsage,commercialUsage:s.commercialUsage,allowPoliticalOrReligiousUsage:s.allowPoliticalOrReligiousUsage,allowAntisocialOrHateUsage:s.allowAntisocialOrHateUsage,creditNotation:s.creditNotation,allowRedistribution:s.allowRedistribution,modification:s.modification,otherLicenseUrl:s.otherLicenseUrl}})}_v0Import(e){return p(this,null,function*(){var e;let t;let n=null==(e=this.parser.json.extensions)?void 0:e.VRM;if(!n)return null;let i=n.meta;if(!i)return null;if(!this.acceptV0Meta)throw Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");return this.needThumbnailImage&&null!=i.texture&&-1!==i.texture&&(t=yield this.parser.getDependency("texture",i.texture)),{metaVersion:"0",allowedUserName:i.allowedUserName,author:i.author,commercialUssageName:i.commercialUssageName,contactInformation:i.contactInformation,licenseName:i.licenseName,otherLicenseUrl:i.otherLicenseUrl,otherPermissionUrl:i.otherPermissionUrl,reference:i.reference,sexualUssageName:i.sexualUssageName,texture:null!=t?t:void 0,title:i.title,version:i.version,violentUssageName:i.violentUssageName}})}_extractGLTFImage(e){return p(this,null,function*(){var t,n,i;let r=null==(t=this.parser.json.images)?void 0:t[e];if(null==r)return console.warn("VRMMetaLoaderPlugin: Attempt to use images[".concat(e,"] of glTF as a thumbnail but the image doesn't exist")),null;let o=r.uri;if(null!=r.bufferView){let e=new Blob([(yield this.parser.getDependency("bufferView",r.bufferView))],{type:r.mimeType});o=URL.createObjectURL(e)}return null==o?(console.warn("VRMMetaLoaderPlugin: Attempt to use images[".concat(e,"] of glTF as a thumbnail but the image couldn't load properly")),null):yield new l.S3k().loadAsync((n=o,i=this.parser.options.path,"string"!=typeof n||""===n?"":(/^https?:\/\//i.test(i)&&/^\//.test(n)&&(i=i.replace(/(^https?:\/\/[^/]+).*/i,"$1")),/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n)?n:i+n))).catch(e=>(console.error(e),console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image"),null))})}constructor(e,t){var n,i,r;this.parser=e,this.needThumbnailImage=null!=(n=null==t?void 0:t.needThumbnailImage)&&n,this.acceptLicenseUrls=null!=(i=null==t?void 0:t.acceptLicenseUrls)?i:["https://vrm.dev/licenses/1.0/"],this.acceptV0Meta=null==(r=null==t?void 0:t.acceptV0Meta)||r}},eN=class{update(e){this.humanoid.update(),this.lookAt&&this.lookAt.update(e),this.expressionManager&&this.expressionManager.update()}constructor(e){this.scene=e.scene,this.meta=e.meta,this.humanoid=e.humanoid,this.expressionManager=e.expressionManager,this.firstPerson=e.firstPerson,this.lookAt=e.lookAt}},eU=class extends eN{update(e){super.update(e),this.nodeConstraintManager&&this.nodeConstraintManager.update(),this.springBoneManager&&this.springBoneManager.update(e),this.materials&&this.materials.forEach(t=>{t.update&&t.update(e)})}constructor(e){super(e),this.materials=e.materials,this.springBoneManager=e.springBoneManager,this.nodeConstraintManager=e.nodeConstraintManager}},eO=Object.defineProperty,eF=Object.getOwnPropertySymbols,eD=Object.prototype.hasOwnProperty,eV=Object.prototype.propertyIsEnumerable,eH=(e,t,n)=>t in e?eO(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,eB=(e,t)=>{for(var n in t||(t={}))eD.call(t,n)&&eH(e,n,t[n]);if(eF)for(var n of eF(t))eV.call(t,n)&&eH(e,n,t[n]);return e},ej=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),ek={"":3e3,srgb:3001},eW=class{get pending(){return Promise.all(this._pendings)}assignPrimitive(e,t){null!=t&&(this._materialParams[e]=t)}assignColor(e,t,n){null!=t&&(this._materialParams[e]=new l.Ilk().fromArray(t),n&&this._materialParams[e].convertSRGBToLinear())}assignTexture(e,t,n){return ej(this,null,function*(){let i=ej(this,null,function*(){var i,r;null!=t&&(yield this._parser.assignTexture(this._materialParams,e,t),n&&(i=this._materialParams[e],r="srgb",parseInt(l.UZH,10)>=152?i.colorSpace=r:i.encoding=ek[r]))});return this._pendings.push(i),i})}assignTextureByIndex(e,t,n){return ej(this,null,function*(){return this.assignTexture(e,null!=t?{index:t}:void 0,n)})}constructor(e,t){this._parser=e,this._materialParams=t,this._pendings=[]}},ez={None:"none",ScreenCoordinates:"screenCoordinates"},eG={3e3:"",3001:"srgb"};function eX(e){return parseInt(l.UZH,10)>=152?e.colorSpace:eG[e.encoding]}var eY=class extends l.jyz{get color(){return this.uniforms.litFactor.value}set color(e){this.uniforms.litFactor.value=e}get map(){return this.uniforms.map.value}set map(e){this.uniforms.map.value=e}get normalMap(){return this.uniforms.normalMap.value}set normalMap(e){this.uniforms.normalMap.value=e}get normalScale(){return this.uniforms.normalScale.value}set normalScale(e){this.uniforms.normalScale.value=e}get emissive(){return this.uniforms.emissive.value}set emissive(e){this.uniforms.emissive.value=e}get emissiveIntensity(){return this.uniforms.emissiveIntensity.value}set emissiveIntensity(e){this.uniforms.emissiveIntensity.value=e}get emissiveMap(){return this.uniforms.emissiveMap.value}set emissiveMap(e){this.uniforms.emissiveMap.value=e}get shadeColorFactor(){return this.uniforms.shadeColorFactor.value}set shadeColorFactor(e){this.uniforms.shadeColorFactor.value=e}get shadeMultiplyTexture(){return this.uniforms.shadeMultiplyTexture.value}set shadeMultiplyTexture(e){this.uniforms.shadeMultiplyTexture.value=e}get shadingShiftFactor(){return this.uniforms.shadingShiftFactor.value}set shadingShiftFactor(e){this.uniforms.shadingShiftFactor.value=e}get shadingShiftTexture(){return this.uniforms.shadingShiftTexture.value}set shadingShiftTexture(e){this.uniforms.shadingShiftTexture.value=e}get shadingShiftTextureScale(){return this.uniforms.shadingShiftTextureScale.value}set shadingShiftTextureScale(e){this.uniforms.shadingShiftTextureScale.value=e}get shadingToonyFactor(){return this.uniforms.shadingToonyFactor.value}set shadingToonyFactor(e){this.uniforms.shadingToonyFactor.value=e}get giEqualizationFactor(){return this.uniforms.giEqualizationFactor.value}set giEqualizationFactor(e){this.uniforms.giEqualizationFactor.value=e}get matcapFactor(){return this.uniforms.matcapFactor.value}set matcapFactor(e){this.uniforms.matcapFactor.value=e}get matcapTexture(){return this.uniforms.matcapTexture.value}set matcapTexture(e){this.uniforms.matcapTexture.value=e}get parametricRimColorFactor(){return this.uniforms.parametricRimColorFactor.value}set parametricRimColorFactor(e){this.uniforms.parametricRimColorFactor.value=e}get rimMultiplyTexture(){return this.uniforms.rimMultiplyTexture.value}set rimMultiplyTexture(e){this.uniforms.rimMultiplyTexture.value=e}get rimLightingMixFactor(){return this.uniforms.rimLightingMixFactor.value}set rimLightingMixFactor(e){this.uniforms.rimLightingMixFactor.value=e}get parametricRimFresnelPowerFactor(){return this.uniforms.parametricRimFresnelPowerFactor.value}set parametricRimFresnelPowerFactor(e){this.uniforms.parametricRimFresnelPowerFactor.value=e}get parametricRimLiftFactor(){return this.uniforms.parametricRimLiftFactor.value}set parametricRimLiftFactor(e){this.uniforms.parametricRimLiftFactor.value=e}get outlineWidthMultiplyTexture(){return this.uniforms.outlineWidthMultiplyTexture.value}set outlineWidthMultiplyTexture(e){this.uniforms.outlineWidthMultiplyTexture.value=e}get outlineWidthFactor(){return this.uniforms.outlineWidthFactor.value}set outlineWidthFactor(e){this.uniforms.outlineWidthFactor.value=e}get outlineColorFactor(){return this.uniforms.outlineColorFactor.value}set outlineColorFactor(e){this.uniforms.outlineColorFactor.value=e}get outlineLightingMixFactor(){return this.uniforms.outlineLightingMixFactor.value}set outlineLightingMixFactor(e){this.uniforms.outlineLightingMixFactor.value=e}get uvAnimationMaskTexture(){return this.uniforms.uvAnimationMaskTexture.value}set uvAnimationMaskTexture(e){this.uniforms.uvAnimationMaskTexture.value=e}get uvAnimationScrollXOffset(){return this.uniforms.uvAnimationScrollXOffset.value}set uvAnimationScrollXOffset(e){this.uniforms.uvAnimationScrollXOffset.value=e}get uvAnimationScrollYOffset(){return this.uniforms.uvAnimationScrollYOffset.value}set uvAnimationScrollYOffset(e){this.uniforms.uvAnimationScrollYOffset.value=e}get uvAnimationRotationPhase(){return this.uniforms.uvAnimationRotationPhase.value}set uvAnimationRotationPhase(e){this.uniforms.uvAnimationRotationPhase.value=e}get ignoreVertexColor(){return this._ignoreVertexColor}set ignoreVertexColor(e){this._ignoreVertexColor=e,this.needsUpdate=!0}get v0CompatShade(){return this._v0CompatShade}set v0CompatShade(e){this._v0CompatShade=e,this.needsUpdate=!0}get debugMode(){return this._debugMode}set debugMode(e){this._debugMode=e,this.needsUpdate=!0}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,this.needsUpdate=!0}get isOutline(){return this._isOutline}set isOutline(e){this._isOutline=e,this.needsUpdate=!0}get isMToonMaterial(){return!0}update(e){this._uploadUniformsWorkaround(),this._updateUVAnimation(e)}copy(e){return super.copy(e),this.map=e.map,this.normalMap=e.normalMap,this.emissiveMap=e.emissiveMap,this.shadeMultiplyTexture=e.shadeMultiplyTexture,this.shadingShiftTexture=e.shadingShiftTexture,this.matcapTexture=e.matcapTexture,this.rimMultiplyTexture=e.rimMultiplyTexture,this.outlineWidthMultiplyTexture=e.outlineWidthMultiplyTexture,this.uvAnimationMaskTexture=e.uvAnimationMaskTexture,this.normalMapType=e.normalMapType,this.uvAnimationScrollXSpeedFactor=e.uvAnimationScrollXSpeedFactor,this.uvAnimationScrollYSpeedFactor=e.uvAnimationScrollYSpeedFactor,this.uvAnimationRotationSpeedFactor=e.uvAnimationRotationSpeedFactor,this.ignoreVertexColor=e.ignoreVertexColor,this.v0CompatShade=e.v0CompatShade,this.debugMode=e.debugMode,this.outlineWidthMode=e.outlineWidthMode,this.isOutline=e.isOutline,this.needsUpdate=!0,this}_updateUVAnimation(e){this.uniforms.uvAnimationScrollXOffset.value+=e*this.uvAnimationScrollXSpeedFactor,this.uniforms.uvAnimationScrollYOffset.value+=e*this.uvAnimationScrollYSpeedFactor,this.uniforms.uvAnimationRotationPhase.value+=e*this.uvAnimationRotationSpeedFactor,this.uniforms.alphaTest.value=this.alphaTest,this.uniformsNeedUpdate=!0}_uploadUniformsWorkaround(){this.uniforms.opacity.value=this.opacity,this._updateTextureMatrix(this.uniforms.map,this.uniforms.mapUvTransform),this._updateTextureMatrix(this.uniforms.normalMap,this.uniforms.normalMapUvTransform),this._updateTextureMatrix(this.uniforms.emissiveMap,this.uniforms.emissiveMapUvTransform),this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture,this.uniforms.shadeMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.shadingShiftTexture,this.uniforms.shadingShiftTextureUvTransform),this._updateTextureMatrix(this.uniforms.matcapTexture,this.uniforms.matcapTextureUvTransform),this._updateTextureMatrix(this.uniforms.rimMultiplyTexture,this.uniforms.rimMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.outlineWidthMultiplyTexture,this.uniforms.outlineWidthMultiplyTextureUvTransform),this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture,this.uniforms.uvAnimationMaskTextureUvTransform),this.uniformsNeedUpdate=!0}_generateDefines(){let e=parseInt(l.UZH,10),t=null!==this.outlineWidthMultiplyTexture,n=null!==this.map||null!==this.normalMap||null!==this.emissiveMap||null!==this.shadeMultiplyTexture||null!==this.shadingShiftTexture||null!==this.rimMultiplyTexture||null!==this.uvAnimationMaskTexture;return{THREE_VRM_THREE_REVISION:e,OUTLINE:this._isOutline,MTOON_USE_UV:t||n,MTOON_UVS_VERTEX_ONLY:t&&!n,V0_COMPAT_SHADE:this._v0CompatShade,USE_SHADEMULTIPLYTEXTURE:null!==this.shadeMultiplyTexture,USE_SHADINGSHIFTTEXTURE:null!==this.shadingShiftTexture,USE_MATCAPTEXTURE:null!==this.matcapTexture,USE_RIMMULTIPLYTEXTURE:null!==this.rimMultiplyTexture,USE_OUTLINEWIDTHMULTIPLYTEXTURE:this._isOutline&&null!==this.outlineWidthMultiplyTexture,USE_UVANIMATIONMASKTEXTURE:null!==this.uvAnimationMaskTexture,IGNORE_VERTEX_COLOR:!0===this._ignoreVertexColor,DEBUG_NORMAL:"normal"===this._debugMode,DEBUG_LITSHADERATE:"litShadeRate"===this._debugMode,DEBUG_UV:"uv"===this._debugMode,OUTLINE_WIDTH_SCREEN:this._isOutline&&this._outlineWidthMode===ez.ScreenCoordinates}}_updateTextureMatrix(e,t){e.value&&(e.value.matrixAutoUpdate&&e.value.updateMatrix(),t.value.copy(e.value.matrix))}constructor(e={}){var t;super({vertexShader:"// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  varying vec2 vUv;\n\n  // COMPAT: pre-r151 uses a common uvTransform\n  #if THREE_VRM_THREE_REVISION < 151\n    uniform mat3 uvTransform;\n  #endif\n#endif\n\n// #include <uv2_pars_vertex>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    attribute vec2 uv2;\n    varying vec2 vUv2;\n    uniform mat3 uv2Transform;\n  #endif\n#endif\n\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n  uniform sampler2D outlineWidthMultiplyTexture;\n  uniform mat3 outlineWidthMultiplyTextureUvTransform;\n#endif\n\nuniform float outlineWidthFactor;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    // COMPAT: pre-r151 uses a common uvTransform\n    #if THREE_VRM_THREE_REVISION >= 151\n      vUv = uv;\n    #else\n      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    #endif\n  #endif\n\n  // #include <uv2_vertex>\n  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n  #if THREE_VRM_THREE_REVISION < 151\n    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n    #endif\n  #endif\n\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  #ifdef OUTLINE\n    float worldNormalLength = length( transformedNormal );\n    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;\n\n    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;\n      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;\n      outlineOffset *= outlineTex;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;\n    #endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}",fragmentShader:"// #define PHONG\n\nuniform vec3 litFactor;\n\nuniform float opacity;\n\nuniform vec3 shadeColorFactor;\n#ifdef USE_SHADEMULTIPLYTEXTURE\n  uniform sampler2D shadeMultiplyTexture;\n  uniform mat3 shadeMultiplyTextureUvTransform;\n#endif\n\nuniform float shadingShiftFactor;\nuniform float shadingToonyFactor;\n\n#ifdef USE_SHADINGSHIFTTEXTURE\n  uniform sampler2D shadingShiftTexture;\n  uniform mat3 shadingShiftTextureUvTransform;\n  uniform float shadingShiftTextureScale;\n#endif\n\nuniform float giEqualizationFactor;\n\nuniform vec3 parametricRimColorFactor;\n#ifdef USE_RIMMULTIPLYTEXTURE\n  uniform sampler2D rimMultiplyTexture;\n  uniform mat3 rimMultiplyTextureUvTransform;\n#endif\nuniform float rimLightingMixFactor;\nuniform float parametricRimFresnelPowerFactor;\nuniform float parametricRimLiftFactor;\n\n#ifdef USE_MATCAPTEXTURE\n  uniform vec3 matcapFactor;\n  uniform sampler2D matcapTexture;\n  uniform mat3 matcapTextureUvTransform;\n#endif\n\nuniform vec3 emissive;\nuniform float emissiveIntensity;\n\nuniform vec3 outlineColorFactor;\nuniform float outlineLightingMixFactor;\n\n#ifdef USE_UVANIMATIONMASKTEXTURE\n  uniform sampler2D uvAnimationMaskTexture;\n  uniform mat3 uvAnimationMaskTextureUvTransform;\n#endif\n\nuniform float uvAnimationScrollXOffset;\nuniform float uvAnimationScrollYOffset;\nuniform float uvAnimationRotationPhase;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n// #include <uv2_pars_fragment>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    varying vec2 vUv2;\n  #endif\n#endif\n\n#include <map_pars_fragment>\n\n#ifdef USE_MAP\n  uniform mat3 mapUvTransform;\n#endif\n\n// #include <alphamap_pars_fragment>\n\n#include <alphatest_pars_fragment>\n\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n\n#ifdef USE_EMISSIVEMAP\n  uniform mat3 emissiveMapUvTransform;\n#endif\n\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\n// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>\n#if THREE_VRM_THREE_REVISION < 151\n  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  }\n#endif\n\n#include <lights_pars_begin>\n\n#include <normal_pars_fragment>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingShift;\n};\n\nfloat linearstep( float a, float b, float t ) {\n  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );\n}\n\n/**\n * Convert NdotL into toon shading factor using shadingShift and shadingToony\n */\nfloat getShading(\n  const in float dotNL,\n  const in float shadow,\n  const in float shadingShift\n) {\n  float shading = dotNL;\n  shading = shading + shadingShift;\n  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );\n  shading *= shadow;\n  return shading;\n}\n\n/**\n * Mix diffuseColor and shadeColor using shading factor and light color\n */\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float shading,\n  in vec3 lightColor\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( shading * lightColor ) );\n  #endif\n\n  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );\n\n  // The \"comment out if you want to PBR absolutely\" line\n  #ifdef V0_COMPAT_SHADE\n    col = min( col, material.diffuseColor );\n  #endif\n\n  return col;\n}\n\n// COMPAT: pre-r156 uses a struct GeometricContext\n#if THREE_VRM_THREE_REVISION >= 157\n  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#else\n  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#endif\n\n#define RE_Direct RE_Direct_MToon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform mat3 normalMapUvTransform;\n  uniform vec2 normalScale;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126, r151\n  #if THREE_VRM_THREE_REVISION >= 151\n\n    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\n      vec3 q0 = dFdx( eye_pos.xyz );\n      vec3 q1 = dFdy( eye_pos.xyz );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = surf_norm;\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\n      return mat3( T * scale, B * scale, N );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMATIONMASKTEXTURE\n      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;\n      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;\n    #endif\n\n    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );\n    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );\n    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( litFactor, opacity );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;\n    vec4 sampledDiffuseColor = texture2D( map, mapUv );\n    #ifdef DECODE_VIDEO_TEXTURE\n      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n    #endif\n    diffuseColor *= sampledDiffuseColor;\n  #endif\n\n  // #include <color_fragment>\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    diffuseColor.rgb *= vColor;\n  #endif\n\n  // #include <alphamap_fragment>\n\n  #include <alphatest_fragment>\n\n  // #include <specularmap_fragment>\n\n  // #include <normal_fragment_begin>\n  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n  #ifdef FLAT_SHADED\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n  #else\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n      normal *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_NORMALMAP\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n\n  #endif\n\n  #ifdef USE_NORMALMAP_TANGENTSPACE\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn[0] *= faceDirection;\n      tbn[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_CLEARCOAT_NORMALMAP\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn2[0] *= faceDirection;\n      tbn2[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  // non perturbed normal for clearcoat among others\n\n  vec3 nonPerturbedNormal = normal;\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      normal = normal * faceDirection;\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    // COMPAT: pre-r151\n    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )\n\n      normal = normalize( tbn * mapN );\n\n    #else\n\n      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;\n    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColorFactor;\n  #ifdef USE_SHADEMULTIPLYTEXTURE\n    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;\n  #endif\n\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    material.shadeColor.rgb *= vColor;\n  #endif\n\n  material.shadingShift = shadingShiftFactor;\n  #ifdef USE_SHADINGSHIFTTEXTURE\n    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;\n  #endif\n\n  // #include <lights_fragment_begin>\n\n  // MToon Specific changes:\n  // Since we want to take shadows into account of shading instead of irradiance,\n  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.\n\n  // COMPAT: pre-r156 uses a struct GeometricContext\n  #if THREE_VRM_THREE_REVISION >= 157\n    vec3 geometryPosition = - vViewPosition;\n    vec3 geometryNormal = normal;\n    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    vec3 geometryClearcoatNormal;\n\n    #ifdef USE_CLEARCOAT\n\n      geometryClearcoatNormal = clearcoatNormal;\n\n    #endif\n  #else\n    GeometricContext geometry;\n\n    geometry.position = - vViewPosition;\n    geometry.normal = normal;\n    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    #ifdef USE_CLEARCOAT\n\n      geometry.clearcoatNormal = clearcoatNormal;\n\n    #endif\n  #endif\n\n  IncidentLight directLight;\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float shadow;\n\n  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n      pointLight = pointLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getPointLightInfo( pointLight, geometryPosition, directLight );\n      #else\n        getPointLightInfo( pointLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n      spotLight = spotLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getSpotLightInfo( spotLight, geometryPosition, directLight );\n      #else\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n      directionalLight = directionalLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getDirectionalLightInfo( directionalLight, directLight );\n      #else\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n  //   RectAreaLight rectAreaLight;\n\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  //     rectAreaLight = rectAreaLights[ i ];\n  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n  //   }\n  //   #pragma unroll_loop_end\n\n  // #endif\n\n  #if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    // COMPAT: pre-r156 uses a struct GeometricContext\n    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES\n    #if THREE_VRM_THREE_REVISION >= 157\n      #if defined( USE_LIGHT_PROBES )\n        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n      #endif\n    #else\n      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n    #endif\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n      #pragma unroll_loop_start\n      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n        // COMPAT: pre-r156 uses a struct GeometricContext\n        #if THREE_VRM_THREE_REVISION >= 157\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n        #else\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n        #endif\n\n      }\n      #pragma unroll_loop_end\n\n    #endif\n\n  #endif\n\n  // #if defined( RE_IndirectSpecular )\n\n  //   vec3 radiance = vec3( 0.0 );\n  //   vec3 clearcoatRadiance = vec3( 0.0 );\n\n  // #endif\n\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    reflectedLight.directSpecular /= PI;\n  #endif\n  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );\n\n  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );\n\n  #ifdef USE_MATCAPTEXTURE\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;\n      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;\n      rim += matcapFactor * matcap;\n    }\n  #endif\n\n  #ifdef USE_RIMMULTIPLYTEXTURE\n    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;\n  #endif\n\n  col += rimMix * rim;\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  #if defined( OUTLINE )\n    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );\n  #endif\n\n  #ifdef OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}\n"}),this.uvAnimationScrollXSpeedFactor=0,this.uvAnimationScrollYSpeedFactor=0,this.uvAnimationRotationSpeedFactor=0,this.fog=!0,this.normalMapType=l.IOt,this._ignoreVertexColor=!0,this._v0CompatShade=!1,this._debugMode="none",this._outlineWidthMode=ez.None,this._isOutline=!1,e.transparentWithZWrite&&(e.depthWrite=!0),delete e.transparentWithZWrite,e.fog=!0,e.lights=!0,e.clipping=!0,this.uniforms=l.rDY.merge([u.UniformsLib.common,u.UniformsLib.normalmap,u.UniformsLib.emissivemap,u.UniformsLib.fog,u.UniformsLib.lights,{litFactor:{value:new l.Ilk(1,1,1)},mapUvTransform:{value:new l.Vkp},colorAlpha:{value:1},normalMapUvTransform:{value:new l.Vkp},shadeColorFactor:{value:new l.Ilk(0,0,0)},shadeMultiplyTexture:{value:null},shadeMultiplyTextureUvTransform:{value:new l.Vkp},shadingShiftFactor:{value:0},shadingShiftTexture:{value:null},shadingShiftTextureUvTransform:{value:new l.Vkp},shadingShiftTextureScale:{value:1},shadingToonyFactor:{value:.9},giEqualizationFactor:{value:.9},matcapFactor:{value:new l.Ilk(1,1,1)},matcapTexture:{value:null},matcapTextureUvTransform:{value:new l.Vkp},parametricRimColorFactor:{value:new l.Ilk(0,0,0)},rimMultiplyTexture:{value:null},rimMultiplyTextureUvTransform:{value:new l.Vkp},rimLightingMixFactor:{value:1},parametricRimFresnelPowerFactor:{value:5},parametricRimLiftFactor:{value:0},emissive:{value:new l.Ilk(0,0,0)},emissiveIntensity:{value:1},emissiveMapUvTransform:{value:new l.Vkp},outlineWidthMultiplyTexture:{value:null},outlineWidthMultiplyTextureUvTransform:{value:new l.Vkp},outlineWidthFactor:{value:0},outlineColorFactor:{value:new l.Ilk(0,0,0)},outlineLightingMixFactor:{value:1},uvAnimationMaskTexture:{value:null},uvAnimationMaskTextureUvTransform:{value:new l.Vkp},uvAnimationScrollXOffset:{value:0},uvAnimationScrollYOffset:{value:0},uvAnimationRotationPhase:{value:0}},null!=(t=e.uniforms)?t:{}]),this.setValues(e),this._uploadUniformsWorkaround(),this.customProgramCacheKey=()=>[...Object.entries(this._generateDefines()).map(e=>{let[t,n]=e;return"".concat(t,":").concat(n)}),this.matcapTexture?"matcapTextureColorSpace:".concat(eX(this.matcapTexture)):"",this.shadeMultiplyTexture?"shadeMultiplyTextureColorSpace:".concat(eX(this.shadeMultiplyTexture)):"",this.rimMultiplyTexture?"rimMultiplyTextureColorSpace:".concat(eX(this.rimMultiplyTexture)):""].join(","),this.onBeforeCompile=e=>{let t=parseInt(l.UZH,10),n=Object.entries(eB(eB({},this._generateDefines()),this.defines)).filter(e=>{let[t,n]=e;return!!n}).map(e=>{let[t,n]=e;return"#define ".concat(t," ").concat(n)}).join("\n")+"\n";e.vertexShader=n+e.vertexShader,e.fragmentShader=n+e.fragmentShader,t<154&&(e.fragmentShader=e.fragmentShader.replace("#include <colorspace_fragment>","#include <encodings_fragment>"))}}},eZ=new Set(["1.0","1.0-beta"]),eq=class e{get name(){return e.EXTENSION_NAME}beforeRoot(){return ej(this,null,function*(){this._removeUnlitExtensionIfMToonExists()})}afterRoot(e){return ej(this,null,function*(){e.userData.vrmMToonMaterials=Array.from(this._mToonMaterialSet)})}getMaterialType(e){return this._getMToonExtension(e)?this.materialType:null}extendMaterialParams(e,t){let n=this._getMToonExtension(e);return n?this._extendMaterialParams(n,t):null}loadMesh(e){return ej(this,null,function*(){var t;let n=this.parser,i=null==(t=n.json.meshes)?void 0:t[e];if(null==i)throw Error("MToonMaterialLoaderPlugin: Attempt to use meshes[".concat(e,"] of glTF but the mesh doesn't exist"));let r=i.primitives,o=yield n.loadMesh(e);if(1===r.length){let e=r[0].material;null!=e&&this._setupPrimitive(o,e)}else for(let e=0;e<r.length;e++){let t=o.children[e],n=r[e].material;null!=n&&this._setupPrimitive(t,n)}return o})}_removeUnlitExtensionIfMToonExists(){let e=this.parser.json.materials;null==e||e.map((e,t)=>{var n;this._getMToonExtension(t)&&null!=(n=e.extensions)&&n.KHR_materials_unlit&&delete e.extensions.KHR_materials_unlit})}_getMToonExtension(t){var n,i;let r=null==(n=this.parser.json.materials)?void 0:n[t];if(null==r){console.warn("MToonMaterialLoaderPlugin: Attempt to use materials[".concat(t,"] of glTF but the material doesn't exist"));return}let o=null==(i=r.extensions)?void 0:i[e.EXTENSION_NAME];if(null==o)return;let a=o.specVersion;if(!eZ.has(a)){console.warn("MToonMaterialLoaderPlugin: Unknown ".concat(e.EXTENSION_NAME,' specVersion "').concat(a,'"'));return}return o}_extendMaterialParams(e,t){return ej(this,null,function*(){var n;delete t.metalness,delete t.roughness;let i=new eW(this.parser,t);i.assignPrimitive("transparentWithZWrite",e.transparentWithZWrite),i.assignColor("shadeColorFactor",e.shadeColorFactor),i.assignTexture("shadeMultiplyTexture",e.shadeMultiplyTexture,!0),i.assignPrimitive("shadingShiftFactor",e.shadingShiftFactor),i.assignTexture("shadingShiftTexture",e.shadingShiftTexture,!0),i.assignPrimitive("shadingShiftTextureScale",null==(n=e.shadingShiftTexture)?void 0:n.scale),i.assignPrimitive("shadingToonyFactor",e.shadingToonyFactor),i.assignPrimitive("giEqualizationFactor",e.giEqualizationFactor),i.assignColor("matcapFactor",e.matcapFactor),i.assignTexture("matcapTexture",e.matcapTexture,!0),i.assignColor("parametricRimColorFactor",e.parametricRimColorFactor),i.assignTexture("rimMultiplyTexture",e.rimMultiplyTexture,!0),i.assignPrimitive("rimLightingMixFactor",e.rimLightingMixFactor),i.assignPrimitive("parametricRimFresnelPowerFactor",e.parametricRimFresnelPowerFactor),i.assignPrimitive("parametricRimLiftFactor",e.parametricRimLiftFactor),i.assignPrimitive("outlineWidthMode",e.outlineWidthMode),i.assignPrimitive("outlineWidthFactor",e.outlineWidthFactor),i.assignTexture("outlineWidthMultiplyTexture",e.outlineWidthMultiplyTexture,!1),i.assignColor("outlineColorFactor",e.outlineColorFactor),i.assignPrimitive("outlineLightingMixFactor",e.outlineLightingMixFactor),i.assignTexture("uvAnimationMaskTexture",e.uvAnimationMaskTexture,!1),i.assignPrimitive("uvAnimationScrollXSpeedFactor",e.uvAnimationScrollXSpeedFactor),i.assignPrimitive("uvAnimationScrollYSpeedFactor",e.uvAnimationScrollYSpeedFactor),i.assignPrimitive("uvAnimationRotationSpeedFactor",e.uvAnimationRotationSpeedFactor),i.assignPrimitive("v0CompatShade",this.v0CompatShade),i.assignPrimitive("debugMode",this.debugMode),yield i.pending})}_setupPrimitive(e,t){let n=this._getMToonExtension(t);if(n){let t=this._parseRenderOrder(n);e.renderOrder=t+this.renderOrderOffset,this._generateOutline(e),this._addToMaterialSet(e);return}}_shouldGenerateOutline(e){return"string"==typeof e.outlineWidthMode&&"none"!==e.outlineWidthMode&&"number"==typeof e.outlineWidthFactor&&e.outlineWidthFactor>0}_generateOutline(e){let t=e.material;if(!(t instanceof l.F5T)||!this._shouldGenerateOutline(t))return;e.material=[t];let n=t.clone();n.name+=" (Outline)",n.isOutline=!0,n.side=l._Li,e.material.push(n);let i=e.geometry,r=i.index?i.index.count:i.attributes.position.count/3;i.addGroup(0,r,0),i.addGroup(0,r,1)}_addToMaterialSet(e){let t=e.material,n=new Set;for(let e of(Array.isArray(t)?t.forEach(e=>n.add(e)):n.add(t),n))this._mToonMaterialSet.add(e)}_parseRenderOrder(e){var t;return(e.transparentWithZWrite?0:19)+(null!=(t=e.renderQueueOffsetNumber)?t:0)}constructor(e,t={}){var n,i,r,o;this.parser=e,this.materialType=null!=(n=t.materialType)?n:eY,this.renderOrderOffset=null!=(i=t.renderOrderOffset)?i:0,this.v0CompatShade=null!=(r=t.v0CompatShade)&&r,this.debugMode=null!=(o=t.debugMode)?o:"none",this._mToonMaterialSet=new Set}};eq.EXTENSION_NAME="VRMC_materials_mtoon";var eQ=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),eJ=class e{get name(){return e.EXTENSION_NAME}extendMaterialParams(e,t){return eQ(this,null,function*(){let n=this._getHDREmissiveMultiplierExtension(e);if(null==n)return;console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead.");let i=n.emissiveMultiplier;t.emissiveIntensity=i})}_getHDREmissiveMultiplierExtension(t){var n,i;let r=null==(n=this.parser.json.materials)?void 0:n[t];if(null==r){console.warn("VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[".concat(t,"] of glTF but the material doesn't exist"));return}let o=null==(i=r.extensions)?void 0:i[e.EXTENSION_NAME];if(null!=o)return o}constructor(e){this.parser=e}};eJ.EXTENSION_NAME="VRMC_materials_hdr_emissiveMultiplier";var eK=Object.defineProperty,e$=Object.defineProperties,e0=Object.getOwnPropertyDescriptors,e1=Object.getOwnPropertySymbols,e3=Object.prototype.hasOwnProperty,e2=Object.prototype.propertyIsEnumerable,e4=(e,t,n)=>t in e?eK(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,e5=(e,t)=>{for(var n in t||(t={}))e3.call(t,n)&&e4(e,n,t[n]);if(e1)for(var n of e1(t))e2.call(t,n)&&e4(e,n,t[n]);return e},e6=(e,t)=>e$(e,e0(t)),e7=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())});function e9(e){return Math.pow(e,2.2)}var e8=class{get name(){return"VRMMaterialsV0CompatPlugin"}beforeRoot(){return e7(this,null,function*(){var e;let t=this.parser.json,n=null==(e=t.extensions)?void 0:e.VRM,i=null==n?void 0:n.materialProperties;i&&(this._populateRenderQueueMap(i),i.forEach((e,n)=>{var i,r;let o=null==(i=t.materials)?void 0:i[n];if(null==o){console.warn("VRMMaterialsV0CompatPlugin: Attempt to use materials[".concat(n,"] of glTF but the material doesn't exist"));return}if("VRM/MToon"===e.shader){let i=this._parseV0MToonProperties(e,o);t.materials[n]=i}else if(null!=(r=e.shader)&&r.startsWith("VRM/Unlit")){let i=this._parseV0UnlitProperties(e,o);t.materials[n]=i}else"VRM_USE_GLTFSHADER"===e.shader||console.warn("VRMMaterialsV0CompatPlugin: Unknown shader: ".concat(e.shader))}))})}_parseV0MToonProperties(e,t){var n,i,r,o,a,s,u,d,h,c,p,m,f,g,_,v,x,M,y,w,T,P,E,R,S,A,b,L,I,C,N,U,O,F,D,V,H,B,j,k,W,z,G,X,Y,Z,q,Q,J,K,$,ee,et,en,ei;let er=null!=(i=null==(n=e.keywordMap)?void 0:n._ALPHABLEND_ON)&&i,eo=(null==(r=e.floatProperties)?void 0:r._ZWrite)===1&&er,ea=this._v0ParseRenderQueue(e),es=null!=(a=null==(o=e.keywordMap)?void 0:o._ALPHATEST_ON)&&a,el=es?null!=(u=null==(s=e.floatProperties)?void 0:s._Cutoff)?u:.5:void 0,eu=(null!=(h=null==(d=e.floatProperties)?void 0:d._CullMode)?h:2)===0,ed=this._portTextureTransform(e),eh=(null!=(p=null==(c=e.vectorProperties)?void 0:c._Color)?p:[1,1,1,1]).map((e,t)=>3===t?e:e9(e)),ec=null==(m=e.textureProperties)?void 0:m._MainTex,ep=null!=ec?{index:ec,extensions:e5({},ed)}:void 0,em=null!=(g=null==(f=e.floatProperties)?void 0:f._BumpScale)?g:1,ef=null==(_=e.textureProperties)?void 0:_._BumpMap,eg=null!=ef?{index:ef,scale:em,extensions:e5({},ed)}:void 0,e_=(null!=(x=null==(v=e.vectorProperties)?void 0:v._EmissionColor)?x:[0,0,0,1]).map(e9),ev=null==(M=e.textureProperties)?void 0:M._EmissionMap,ex=null!=ev?{index:ev,extensions:e5({},ed)}:void 0,eM=(null!=(w=null==(y=e.vectorProperties)?void 0:y._ShadeColor)?w:[.97,.81,.86,1]).map(e9),ey=null==(T=e.textureProperties)?void 0:T._ShadeTexture,ew=null!=ey?{index:ey,extensions:e5({},ed)}:void 0,eT=null!=(E=null==(P=e.floatProperties)?void 0:P._ShadeShift)?E:0,eP=null!=(S=null==(R=e.floatProperties)?void 0:R._ShadeToony)?S:.9;eP=l.M8C.lerp(eP,1,.5+.5*eT),eT=-eT-(1-eP);let eE=null!=(b=null==(A=e.floatProperties)?void 0:A._IndirectLightIntensity)?b:.1,eR=null==(L=e.textureProperties)?void 0:L._SphereAdd,eS=null!=(C=null==(I=e.floatProperties)?void 0:I._RimLightingMix)?C:0,eA=null==(N=e.textureProperties)?void 0:N._RimTexture,eb=null!=eA?{index:eA,extensions:e5({},ed)}:void 0,eL=(null!=(O=null==(U=e.vectorProperties)?void 0:U._RimColor)?O:[0,0,0,1]).map(e9),eI=null!=(D=null==(F=e.floatProperties)?void 0:F._RimFresnelPower)?D:1,eC=null!=(H=null==(V=e.floatProperties)?void 0:V._RimLift)?H:0,eN=["none","worldCoordinates","screenCoordinates"][null!=(j=null==(B=e.floatProperties)?void 0:B._OutlineWidthMode)?j:0],eU=null!=(W=null==(k=e.floatProperties)?void 0:k._OutlineWidth)?W:0;eU*=.01;let eO=null==(z=e.textureProperties)?void 0:z._OutlineWidthTexture,eF=null!=eO?{index:eO,extensions:e5({},ed)}:void 0,eD=(null!=(X=null==(G=e.vectorProperties)?void 0:G._OutlineColor)?X:[0,0,0]).map(e9),eV=(null!=(Z=null==(Y=e.floatProperties)?void 0:Y._OutlineColorMode)?Z:0)===1?null!=(Q=null==(q=e.floatProperties)?void 0:q._OutlineLightingMix)?Q:1:0,eH=null==(J=e.textureProperties)?void 0:J._UvAnimMaskTexture,eB=null!=eH?{index:eH,extensions:e5({},ed)}:void 0,ej=null!=($=null==(K=e.floatProperties)?void 0:K._UvAnimScrollX)?$:0,ek=null!=(et=null==(ee=e.floatProperties)?void 0:ee._UvAnimScrollY)?et:0;null!=ek&&(ek=-ek);let eW={specVersion:"1.0",transparentWithZWrite:eo,renderQueueOffsetNumber:ea,shadeColorFactor:eM,shadeMultiplyTexture:ew,shadingShiftFactor:eT,shadingToonyFactor:eP,giEqualizationFactor:eE?1-eE:void 0,matcapFactor:null!=eR?[1,1,1]:void 0,matcapTexture:null!=eR?{index:eR}:void 0,rimLightingMixFactor:eS,rimMultiplyTexture:eb,parametricRimColorFactor:eL,parametricRimFresnelPowerFactor:eI,parametricRimLiftFactor:eC,outlineWidthMode:eN,outlineWidthFactor:eU,outlineWidthMultiplyTexture:eF,outlineColorFactor:eD,outlineLightingMixFactor:eV,uvAnimationMaskTexture:eB,uvAnimationScrollXSpeedFactor:ej,uvAnimationScrollYSpeedFactor:ek,uvAnimationRotationSpeedFactor:null!=(ei=null==(en=e.floatProperties)?void 0:en._UvAnimRotation)?ei:0};return e6(e5({},t),{pbrMetallicRoughness:{baseColorFactor:eh,baseColorTexture:ep},normalTexture:eg,emissiveTexture:ex,emissiveFactor:e_,alphaMode:er?"BLEND":es?"MASK":"OPAQUE",alphaCutoff:el,doubleSided:eu,extensions:{VRMC_materials_mtoon:eW}})}_parseV0UnlitProperties(e,t){var n,i,r,o,a;let s="VRM/UnlitTransparentZWrite"===e.shader,l="VRM/UnlitTransparent"===e.shader||s,u=this._v0ParseRenderQueue(e),d="VRM/UnlitCutout"===e.shader,h=d?null!=(i=null==(n=e.floatProperties)?void 0:n._Cutoff)?i:.5:void 0,c=this._portTextureTransform(e),p=(null!=(o=null==(r=e.vectorProperties)?void 0:r._Color)?o:[1,1,1,1]).map(e9),m=null==(a=e.textureProperties)?void 0:a._MainTex,f=null!=m?{index:m,extensions:e5({},c)}:void 0;return e6(e5({},t),{pbrMetallicRoughness:{baseColorFactor:p,baseColorTexture:f},alphaMode:l?"BLEND":d?"MASK":"OPAQUE",alphaCutoff:h,extensions:{VRMC_materials_mtoon:{specVersion:"1.0",transparentWithZWrite:s,renderQueueOffsetNumber:u,shadeColorFactor:p,shadeMultiplyTexture:f}}})}_portTextureTransform(e){var t,n,i,r,o;let a=null==(t=e.vectorProperties)?void 0:t._MainTex;if(null==a)return{};let s=[null!=(n=null==a?void 0:a[0])?n:0,null!=(i=null==a?void 0:a[1])?i:0],l=[null!=(r=null==a?void 0:a[2])?r:1,null!=(o=null==a?void 0:a[3])?o:1];return s[1]=1-l[1]-s[1],{KHR_texture_transform:{offset:s,scale:l}}}_v0ParseRenderQueue(e){var t,n;let i="VRM/UnlitTransparentZWrite"===e.shader,r=(null==(t=e.keywordMap)?void 0:t._ALPHABLEND_ON)!=null||"VRM/UnlitTransparent"===e.shader||i,o=(null==(n=e.floatProperties)?void 0:n._ZWrite)===1||i,a=0;if(r){let t=e.renderQueue;null!=t&&(a=o?this._renderQueueMapTransparentZWrite.get(t):this._renderQueueMapTransparent.get(t))}return a}_populateRenderQueueMap(e){let t=new Set,n=new Set;e.forEach(e=>{var i,r;let o="VRM/UnlitTransparentZWrite"===e.shader,a=(null==(i=e.keywordMap)?void 0:i._ALPHABLEND_ON)!=null||"VRM/UnlitTransparent"===e.shader||o,s=(null==(r=e.floatProperties)?void 0:r._ZWrite)===1||o;if(a){let i=e.renderQueue;null!=i&&(s?n.add(i):t.add(i))}}),t.size>10&&console.warn("VRMMaterialsV0CompatPlugin: This VRM uses ".concat(t.size," render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.")),n.size>10&&console.warn("VRMMaterialsV0CompatPlugin: This VRM uses ".concat(n.size," render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.")),Array.from(t).sort().forEach((e,n)=>{let i=Math.min(Math.max(n-t.size+1,-9),0);this._renderQueueMapTransparent.set(e,i)}),Array.from(n).sort().forEach((e,t)=>{this._renderQueueMapTransparentZWrite.set(e,Math.min(Math.max(t,0),9))})}constructor(e){var t;this.parser=e,this._renderQueueMapTransparent=new Map,this._renderQueueMapTransparentZWrite=new Map;let n=this.parser.json;n.extensionsUsed=null!=(t=n.extensionsUsed)?t:[],-1===n.extensionsUsed.indexOf("KHR_texture_transform")&&n.extensionsUsed.push("KHR_texture_transform")}},te=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),tt=new l.Pa4,tn=class extends l.ZAu{updateMatrixWorld(e){tt.setFromMatrixPosition(this.constraint.destination.matrixWorld),this._attrPosition.setXYZ(0,tt.x,tt.y,tt.z),this.constraint.source&&tt.setFromMatrixPosition(this.constraint.source.matrixWorld),this._attrPosition.setXYZ(1,tt.x,tt.y,tt.z),this._attrPosition.needsUpdate=!0,super.updateMatrixWorld(e)}constructor(e){super(),this._attrPosition=new l.TlE(new Float32Array([0,0,0,0,0,0]),3),this._attrPosition.setUsage(l.dj0);let t=new l.u9r;t.setAttribute("position",this._attrPosition);let n=new l.nls({color:16711935,depthTest:!1,depthWrite:!1});this._line=new l.x12(t,n),this.add(this._line),this.constraint=e}};function ti(e,t){return t.set(e.elements[12],e.elements[13],e.elements[14])}var tr=new l.Pa4,to=new l.Pa4;function ta(e){return e.invert?e.invert():e.inverse(),e}var ts=class{constructor(e,t){this.destination=e,this.source=t,this.weight=1}},tl=new l.Pa4,tu=new l.Pa4,td=new l.Pa4,th=new l._fP,tc=new l._fP,tp=new l._fP,tm=class extends ts{get aimAxis(){return this._aimAxis}set aimAxis(e){this._aimAxis=e,this._v3AimAxis.set("PositiveX"===e?1:"NegativeX"===e?-1:0,"PositiveY"===e?1:"NegativeY"===e?-1:0,"PositiveZ"===e?1:"NegativeZ"===e?-1:0)}get dependencies(){let e=new Set([this.source]);return this.destination.parent&&e.add(this.destination.parent),e}setInitState(){this._dstRestQuat.copy(this.destination.quaternion)}update(){this.destination.updateWorldMatrix(!0,!1),this.source.updateWorldMatrix(!0,!1);let e=th.identity(),t=tc.identity();this.destination.parent&&(this.destination.parent.matrixWorld.decompose(tr,e,to),ta(t.copy(e)));let n=tl.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(e),i=ti(this.source.matrixWorld,tu).sub(ti(this.destination.matrixWorld,td)).normalize(),r=tp.setFromUnitVectors(n,i).premultiply(t).multiply(e).multiply(this._dstRestQuat);this.destination.quaternion.copy(this._dstRestQuat).slerp(r,this.weight)}constructor(e,t){super(e,t),this._aimAxis="PositiveX",this._v3AimAxis=new l.Pa4(1,0,0),this._dstRestQuat=new l._fP}},tf=class{get constraints(){return this._constraints}addConstraint(e){this._constraints.add(e);let t=this._objectConstraintsMap.get(e.destination);null==t&&(t=new Set,this._objectConstraintsMap.set(e.destination,t)),t.add(e)}deleteConstraint(e){this._constraints.delete(e),this._objectConstraintsMap.get(e.destination).delete(e)}setInitState(){let e=new Set,t=new Set;for(let n of this._constraints)this._processConstraint(n,e,t,e=>e.setInitState())}update(){let e=new Set,t=new Set;for(let n of this._constraints)this._processConstraint(n,e,t,e=>e.update())}_processConstraint(e,t,n,i){if(!n.has(e)){if(t.has(e))throw Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");for(let r of(t.add(e),e.dependencies))!function(e,t){let n=[e],i=e.parent;for(;null!==i;)n.unshift(i),i=i.parent;n.forEach(e=>{t(e)})}(r,e=>{let r=this._objectConstraintsMap.get(e);if(r)for(let e of r)this._processConstraint(e,t,n,i)});i(e),n.add(e)}}constructor(){this._constraints=new Set,this._objectConstraintsMap=new Map}},tg=new l._fP,t_=new l._fP,tv=class extends ts{get dependencies(){return new Set([this.source])}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),ta(this._invSrcRestQuat.copy(this.source.quaternion))}update(){let e=tg.copy(this._invSrcRestQuat).multiply(this.source.quaternion),t=t_.copy(this._dstRestQuat).multiply(e);this.destination.quaternion.copy(this._dstRestQuat).slerp(t,this.weight)}constructor(e,t){super(e,t),this._dstRestQuat=new l._fP,this._invSrcRestQuat=new l._fP}},tx=new l.Pa4,tM=new l._fP,ty=new l._fP,tw=class extends ts{get rollAxis(){return this._rollAxis}set rollAxis(e){this._rollAxis=e,this._v3RollAxis.set("X"===e?1:0,"Y"===e?1:0,"Z"===e?1:0)}get dependencies(){return new Set([this.source])}setInitState(){this._dstRestQuat.copy(this.destination.quaternion),ta(this._invDstRestQuat.copy(this._dstRestQuat)),ta(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat)}update(){let e=tM.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat),t=tx.copy(this._v3RollAxis).applyQuaternion(e),n=ty.setFromUnitVectors(t,this._v3RollAxis).premultiply(this._dstRestQuat).multiply(e);this.destination.quaternion.copy(this._dstRestQuat).slerp(n,this.weight)}constructor(e,t){super(e,t),this._rollAxis="X",this._v3RollAxis=new l.Pa4(1,0,0),this._dstRestQuat=new l._fP,this._invDstRestQuat=new l._fP,this._invSrcRestQuatMulDstRestQuat=new l._fP}},tT=new Set(["1.0","1.0-beta"]),tP=class e{get name(){return e.EXTENSION_NAME}afterRoot(e){return te(this,null,function*(){e.userData.vrmNodeConstraintManager=yield this._import(e)})}_import(t){return te(this,null,function*(){var n;let i=this.parser.json;if(!((null==(n=i.extensionsUsed)?void 0:n.indexOf(e.EXTENSION_NAME))!==-1))return null;let r=new tf,o=yield this.parser.getDependencies("node");return o.forEach((t,n)=>{var a;let s=i.nodes[n],l=null==(a=null==s?void 0:s.extensions)?void 0:a[e.EXTENSION_NAME];if(null==l)return;let u=l.specVersion;if(!tT.has(u)){console.warn("VRMNodeConstraintLoaderPlugin: Unknown ".concat(e.EXTENSION_NAME,' specVersion "').concat(u,'"'));return}let d=l.constraint;if(null!=d.roll){let e=this._importRollConstraint(t,o,d.roll);r.addConstraint(e)}else if(null!=d.aim){let e=this._importAimConstraint(t,o,d.aim);r.addConstraint(e)}else if(null!=d.rotation){let e=this._importRotationConstraint(t,o,d.rotation);r.addConstraint(e)}}),t.scene.updateMatrixWorld(),r.setInitState(),r})}_importRollConstraint(e,t,n){let{source:i,rollAxis:r,weight:o}=n,a=new tw(e,t[i]);if(null!=r&&(a.rollAxis=r),null!=o&&(a.weight=o),this.helperRoot){let e=new tn(a);this.helperRoot.add(e)}return a}_importAimConstraint(e,t,n){let{source:i,aimAxis:r,weight:o}=n,a=new tm(e,t[i]);if(null!=r&&(a.aimAxis=r),null!=o&&(a.weight=o),this.helperRoot){let e=new tn(a);this.helperRoot.add(e)}return a}_importRotationConstraint(e,t,n){let{source:i,weight:r}=n,o=new tv(e,t[i]);if(null!=r&&(o.weight=r),this.helperRoot){let e=new tn(o);this.helperRoot.add(e)}return o}constructor(e,t){this.parser=e,this.helperRoot=null==t?void 0:t.helperRoot}};tP.EXTENSION_NAME="VRMC_node_constraint";var tE=(e,t,n)=>new Promise((i,r)=>{var o=e=>{try{s(n.next(e))}catch(e){r(e)}},a=e=>{try{s(n.throw(e))}catch(e){r(e)}},s=e=>e.done?i(e.value):Promise.resolve(e.value).then(o,a);s((n=n.apply(e,t)).next())}),tR=class{},tS=new l.Pa4,tA=new l.Pa4,tb=class extends tR{get type(){return"capsule"}calculateCollision(e,t,n,i){tS.copy(this.offset).applyMatrix4(e),tA.copy(this.tail).applyMatrix4(e),tA.sub(tS);let r=tA.lengthSq();i.copy(t).sub(tS);let o=tA.dot(i);o<=0||(r<=o||tA.multiplyScalar(o/r),i.sub(tA));let a=this.inside?this.radius-n-i.length():i.length()-n-this.radius;return i.normalize(),this.inside&&i.negate(),a}constructor(e){var t,n,i,r;super(),this.offset=null!=(t=null==e?void 0:e.offset)?t:new l.Pa4(0,0,0),this.tail=null!=(n=null==e?void 0:e.tail)?n:new l.Pa4(0,0,0),this.radius=null!=(i=null==e?void 0:e.radius)?i:0,this.inside=null!=(r=null==e?void 0:e.inside)&&r}},tL=new l.Pa4,tI=new l.Vkp,tC=class extends tR{get type(){return"plane"}calculateCollision(e,t,n,i){i.copy(this.offset).applyMatrix4(e),i.negate().add(t),tI.getNormalMatrix(e),tL.copy(this.normal).applyNormalMatrix(tI).normalize();let r=i.dot(tL)-n;return i.copy(tL),r}constructor(e){var t,n;super(),this.offset=null!=(t=null==e?void 0:e.offset)?t:new l.Pa4(0,0,0),this.normal=null!=(n=null==e?void 0:e.normal)?n:new l.Pa4(0,0,1)}},tN=class extends tR{get type(){return"sphere"}calculateCollision(e,t,n,i){i.copy(this.offset).applyMatrix4(e),i.negate().add(t);let r=this.inside?this.radius-n-i.length():i.length()-n-this.radius;return i.normalize(),this.inside&&i.negate(),r}constructor(e){var t,n,i;super(),this.offset=null!=(t=null==e?void 0:e.offset)?t:new l.Pa4(0,0,0),this.radius=null!=(n=null==e?void 0:e.radius)?n:0,this.inside=null!=(i=null==e?void 0:e.inside)&&i}},tU=new l.Pa4,tO=class extends l.u9r{update(){let e=!1,t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,e=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),e=!0);let n=tU.copy(this._shape.tail).divideScalar(this.worldScale);this._currentTail.distanceToSquared(n)>1e-10&&(this._currentTail.copy(n),e=!0),e&&this._buildPosition()}_buildPosition(){tU.copy(this._currentTail).sub(this._currentOffset);let e=tU.length()/this._currentRadius;for(let t=0;t<=16;t++){let n=t/16*Math.PI;this._attrPos.setXYZ(t,-Math.sin(n),-Math.cos(n),0),this._attrPos.setXYZ(17+t,e+Math.sin(n),Math.cos(n),0),this._attrPos.setXYZ(34+t,-Math.sin(n),0,-Math.cos(n)),this._attrPos.setXYZ(51+t,e+Math.sin(n),0,Math.cos(n))}for(let t=0;t<32;t++){let n=t/16*Math.PI;this._attrPos.setXYZ(68+t,0,Math.sin(n),Math.cos(n)),this._attrPos.setXYZ(100+t,e,Math.sin(n),Math.cos(n))}let t=Math.atan2(tU.y,Math.sqrt(tU.x*tU.x+tU.z*tU.z)),n=-Math.atan2(tU.z,tU.x);this.rotateZ(t),this.rotateY(n),this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<34;e++){let t=(e+1)%34;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(68+2*e,34+e,34+t)}for(let e=0;e<32;e++){let t=(e+1)%32;this._attrIndex.setXY(136+2*e,68+e,68+t),this._attrIndex.setXY(200+2*e,100+e,100+t)}this._attrIndex.needsUpdate=!0}constructor(e){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new l.Pa4,this._currentTail=new l.Pa4,this._shape=e,this._attrPos=new l.TlE(new Float32Array(396),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(264),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},tF=class extends l.u9r{update(){let e=!1;this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),e=!0),this._currentNormal.equals(this._shape.normal)||(this._currentNormal.copy(this._shape.normal),e=!0),e&&this._buildPosition()}_buildPosition(){this._attrPos.setXYZ(0,-.5,-.5,0),this._attrPos.setXYZ(1,.5,-.5,0),this._attrPos.setXYZ(2,.5,.5,0),this._attrPos.setXYZ(3,-.5,.5,0),this._attrPos.setXYZ(4,0,0,0),this._attrPos.setXYZ(5,0,0,.25),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this.lookAt(this._currentNormal),this._attrPos.needsUpdate=!0}_buildIndex(){this._attrIndex.setXY(0,0,1),this._attrIndex.setXY(2,1,2),this._attrIndex.setXY(4,2,3),this._attrIndex.setXY(6,3,0),this._attrIndex.setXY(8,4,5),this._attrIndex.needsUpdate=!0}constructor(e){super(),this.worldScale=1,this._currentOffset=new l.Pa4,this._currentNormal=new l.Pa4,this._shape=e,this._attrPos=new l.TlE(new Float32Array(18),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(10),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},tD=class extends l.u9r{update(){let e=!1,t=this._shape.radius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,e=!0),this._currentOffset.equals(this._shape.offset)||(this._currentOffset.copy(this._shape.offset),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){let t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentOffset.x,this._currentOffset.y,this._currentOffset.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){let t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.needsUpdate=!0}constructor(e){super(),this.worldScale=1,this._currentRadius=0,this._currentOffset=new l.Pa4,this._shape=e,this._attrPos=new l.TlE(new Float32Array(288),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(192),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},tV=new l.Pa4,tH=class extends l.ZAu{dispose(){this._geometry.dispose()}updateMatrixWorld(e){this.collider.updateWorldMatrix(!0,!1),this.matrix.copy(this.collider.matrixWorld);let t=this.matrix.elements;this._geometry.worldScale=tV.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(e)}constructor(e){if(super(),this.matrixAutoUpdate=!1,this.collider=e,this.collider.shape instanceof tN)this._geometry=new tD(this.collider.shape);else if(this.collider.shape instanceof tb)this._geometry=new tO(this.collider.shape);else if(this.collider.shape instanceof tC)this._geometry=new tF(this.collider.shape);else throw Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");let t=new l.nls({color:16711935,depthTest:!1,depthWrite:!1});this._line=new l.ejS(this._geometry,t),this.add(this._line)}},tB=class extends l.u9r{update(){let e=!1,t=this._springBone.settings.hitRadius/this.worldScale;this._currentRadius!==t&&(this._currentRadius=t,e=!0),this._currentTail.equals(this._springBone.initialLocalChildPosition)||(this._currentTail.copy(this._springBone.initialLocalChildPosition),e=!0),e&&this._buildPosition()}_buildPosition(){for(let e=0;e<32;e++){let t=e/16*Math.PI;this._attrPos.setXYZ(e,Math.cos(t),Math.sin(t),0),this._attrPos.setXYZ(32+e,0,Math.cos(t),Math.sin(t)),this._attrPos.setXYZ(64+e,Math.sin(t),0,Math.cos(t))}this.scale(this._currentRadius,this._currentRadius,this._currentRadius),this.translate(this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.setXYZ(96,0,0,0),this._attrPos.setXYZ(97,this._currentTail.x,this._currentTail.y,this._currentTail.z),this._attrPos.needsUpdate=!0}_buildIndex(){for(let e=0;e<32;e++){let t=(e+1)%32;this._attrIndex.setXY(2*e,e,t),this._attrIndex.setXY(64+2*e,32+e,32+t),this._attrIndex.setXY(128+2*e,64+e,64+t)}this._attrIndex.setXY(192,96,97),this._attrIndex.needsUpdate=!0}constructor(e){super(),this.worldScale=1,this._currentRadius=0,this._currentTail=new l.Pa4,this._springBone=e,this._attrPos=new l.TlE(new Float32Array(294),3),this.setAttribute("position",this._attrPos),this._attrIndex=new l.TlE(new Uint16Array(194),1),this.setIndex(this._attrIndex),this._buildIndex(),this.update()}},tj=new l.Pa4,tk=class extends l.ZAu{dispose(){this._geometry.dispose()}updateMatrixWorld(e){this.springBone.bone.updateWorldMatrix(!0,!1),this.matrix.copy(this.springBone.bone.matrixWorld);let t=this.matrix.elements;this._geometry.worldScale=tj.set(t[0],t[1],t[2]).length(),this._geometry.update(),super.updateMatrixWorld(e)}constructor(e){super(),this.matrixAutoUpdate=!1,this.springBone=e,this._geometry=new tB(this.springBone);let t=new l.nls({color:16776960,depthTest:!1,depthWrite:!1});this._line=new l.ejS(this._geometry,t),this.add(this._line)}},tW=class extends l.Tme{constructor(e){super(),this.shape=e}},tz=new l.yGw;function tG(e){return e.invert?e.invert():e.getInverse(tz.copy(e)),e}var tX=class{get inverse(){return this._shouldUpdateInverse&&(tG(this._inverseCache.copy(this.matrix)),this._shouldUpdateInverse=!1),this._inverseCache}revert(){this.matrix.elements=this._originalElements}constructor(e){this._inverseCache=new l.yGw,this._shouldUpdateInverse=!0,this.matrix=e,this._originalElements=e.elements,e.elements=new Proxy(e.elements,{set:(e,t,n)=>(this._shouldUpdateInverse=!0,e[t]=n,!0)})}},tY=new l.yGw,tZ=new l.Pa4,tq=new l.Pa4,tQ=new l.Pa4,tJ=new l.Pa4,tK=new l.Pa4,t$=new l.Pa4,t0=new l._fP,t1=new l.yGw,t3=new l.yGw,t2=class{get center(){return this._center}set center(e){var t;null!=(t=this._center)&&t.userData.inverseCacheProxy&&(this._center.userData.inverseCacheProxy.revert(),delete this._center.userData.inverseCacheProxy),this._center=e,this._center&&(this._center.userData.inverseCacheProxy||(this._center.userData.inverseCacheProxy=new tX(this._center.matrixWorld)))}get initialLocalChildPosition(){return this._initialLocalChildPosition}get _parentMatrixWorld(){return this.bone.parent?this.bone.parent.matrixWorld:tY}setInitState(){this._initialLocalMatrix.copy(this.bone.matrix),this._initialLocalRotation.copy(this.bone.quaternion),this.child?this._initialLocalChildPosition.copy(this.child.position):this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(.07);let e=this._getMatrixWorldToCenter(t1);this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(e),this._prevTail.copy(this._currentTail),this._boneAxis.copy(this._initialLocalChildPosition).normalize()}reset(){this.bone.quaternion.copy(this._initialLocalRotation),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix);let e=this._getMatrixWorldToCenter(t1);this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(e),this._prevTail.copy(this._currentTail)}update(e){if(e<=0)return;this._calcWorldSpaceBoneLength(),tJ.setFromMatrixPosition(this.bone.matrixWorld);let t=this._getMatrixWorldToCenter(t1);tK.copy(tJ).applyMatrix4(t);let n=t0.setFromRotationMatrix(t),i=t3.copy(t).multiply(this._parentMatrixWorld),r=tq.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(i).sub(tK).normalize(),o=tQ.copy(this.settings.gravityDir).applyQuaternion(n).normalize(),a=this._getMatrixCenterToWorld(t1);t$.copy(this._currentTail).add(tZ.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1-this.settings.dragForce)).add(tZ.copy(r).multiplyScalar(this.settings.stiffness*e)).add(tZ.copy(o).multiplyScalar(this.settings.gravityPower*e)).applyMatrix4(a),t$.sub(tJ).normalize().multiplyScalar(this._worldSpaceBoneLength).add(tJ),this._collision(t$),t=this._getMatrixWorldToCenter(t1),this._prevTail.copy(this._currentTail),this._currentTail.copy(tZ.copy(t$).applyMatrix4(t));let s=tG(t1.copy(this._parentMatrixWorld).multiply(this._initialLocalMatrix)),l=t0.setFromUnitVectors(this._boneAxis,tZ.copy(t$).applyMatrix4(s).normalize());this.bone.quaternion.copy(this._initialLocalRotation).multiply(l),this.bone.updateMatrix(),this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld,this.bone.matrix)}_collision(e){this.colliderGroups.forEach(t=>{t.colliders.forEach(t=>{let n=t.shape.calculateCollision(t.matrixWorld,e,this.settings.hitRadius,tZ);n<0&&(e.add(tZ.multiplyScalar(-n)),e.sub(tJ).normalize().multiplyScalar(this._worldSpaceBoneLength).add(tJ))})})}_calcWorldSpaceBoneLength(){tZ.setFromMatrixPosition(this.bone.matrixWorld),this.child?tq.setFromMatrixPosition(this.child.matrixWorld):(tq.copy(this._initialLocalChildPosition),tq.applyMatrix4(this.bone.matrixWorld)),this._worldSpaceBoneLength=tZ.sub(tq).length()}_getMatrixCenterToWorld(e){return this._center?e.copy(this._center.matrixWorld):e.identity(),e}_getMatrixWorldToCenter(e){return this._center?e.copy(this._center.userData.inverseCacheProxy.inverse):e.identity(),e}constructor(e,t,n={},i=[]){var r,o,a,s,u,d;this._currentTail=new l.Pa4,this._prevTail=new l.Pa4,this._boneAxis=new l.Pa4,this._worldSpaceBoneLength=0,this._center=null,this._initialLocalMatrix=new l.yGw,this._initialLocalRotation=new l._fP,this._initialLocalChildPosition=new l.Pa4,this.bone=e,this.bone.matrixAutoUpdate=!1,this.child=t,this.settings={hitRadius:null!=(r=n.hitRadius)?r:0,stiffness:null!=(o=n.stiffness)?o:1,gravityPower:null!=(a=n.gravityPower)?a:0,gravityDir:null!=(u=null==(s=n.gravityDir)?void 0:s.clone())?u:new l.Pa4(0,-1,0),dragForce:null!=(d=n.dragForce)?d:.4},this.colliderGroups=i}},t4=class{get joints(){return this._joints}get springBones(){return console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead."),this._joints}get colliderGroups(){let e=new Set;return this._joints.forEach(t=>{t.colliderGroups.forEach(t=>{e.add(t)})}),Array.from(e)}get colliders(){let e=new Set;return this.colliderGroups.forEach(t=>{t.colliders.forEach(t=>{e.add(t)})}),Array.from(e)}addJoint(e){this._joints.add(e);let t=this._objectSpringBonesMap.get(e.bone);null==t&&(t=new Set,this._objectSpringBonesMap.set(e.bone,t)),t.add(e)}addSpringBone(e){console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead."),this.addJoint(e)}deleteJoint(e){this._joints.delete(e),this._objectSpringBonesMap.get(e.bone).delete(e)}deleteSpringBone(e){console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead."),this.deleteJoint(e)}setInitState(){let e=new Set,t=new Set,n=new Set;for(let i of this._joints)this._processSpringBone(i,e,t,n,e=>e.setInitState())}reset(){let e=new Set,t=new Set,n=new Set;for(let i of this._joints)this._processSpringBone(i,e,t,n,e=>e.reset())}update(e){let t=new Set,n=new Set,i=new Set;for(let r of this._joints)this._processSpringBone(r,t,n,i,t=>t.update(e)),function e(t,n){t.children.forEach(t=>{n(t)||e(t,n)})}(r.bone,e=>{var t,n;return(null!=(n=null==(t=this._objectSpringBonesMap.get(e))?void 0:t.size)?n:0)>0||(e.updateWorldMatrix(!1,!1),!1)})}_processSpringBone(e,t,n,i,r){if(!n.has(e)){if(t.has(e)){this._hasWarnedCircularDependency||(console.warn("VRMSpringBoneManager: Circular dependency detected while updating springbones"),this._hasWarnedCircularDependency=!0);return}for(let o of(t.add(e),this._getDependencies(e)))!function(e,t){let n=[],i=e;for(;null!==i;)n.unshift(i),i=i.parent;n.forEach(e=>{t(e)})}(o,e=>{let o=this._objectSpringBonesMap.get(e);if(o)for(let e of o)this._processSpringBone(e,t,n,i,r);else i.has(e)||(e.updateWorldMatrix(!1,!1),i.add(e))});e.bone.updateMatrix(),e.bone.updateWorldMatrix(!1,!1),r(e),i.add(e.bone),n.add(e)}}_getDependencies(e){let t=new Set,n=e.bone.parent;return n&&t.add(n),e.colliderGroups.forEach(e=>{e.colliders.forEach(e=>{t.add(e)})}),t}constructor(){this._joints=new Set,this._hasWarnedCircularDependency=!1,this._objectSpringBonesMap=new Map}},t5="VRMC_springBone_extended_collider",t6=new Set(["1.0","1.0-beta"]),t7=new Set(["1.0"]),t9=class e{get name(){return e.EXTENSION_NAME}afterRoot(e){return tE(this,null,function*(){e.userData.vrmSpringBoneManager=yield this._import(e)})}_import(e){return tE(this,null,function*(){let t=yield this._v1Import(e);if(null!=t)return t;let n=yield this._v0Import(e);return null!=n?n:null})}_v1Import(t){return tE(this,null,function*(){var n,i,r,o,a;let s=t.parser.json;if(!((null==(n=s.extensionsUsed)?void 0:n.indexOf(e.EXTENSION_NAME))!==-1))return null;let u=new t4,d=yield t.parser.getDependencies("node"),h=null==(i=s.extensions)?void 0:i[e.EXTENSION_NAME];if(!h)return null;let c=h.specVersion;if(!t6.has(c))return console.warn("VRMSpringBoneLoaderPlugin: Unknown ".concat(e.EXTENSION_NAME,' specVersion "').concat(c,'"')),null;let p=null==(r=h.colliders)?void 0:r.map((t,n)=>{var i,r,o,a,s,u,h,c,p,m,f,g,_,v,x;let M=d[t.node],y=t.shape,w=null==(i=t.extensions)?void 0:i[t5];if(this.useExtendedColliders&&null!=w){let t=w.specVersion;if(t7.has(t)){let e=w.shape;if(e.sphere)return this._importSphereCollider(M,{offset:new l.Pa4().fromArray(null!=(r=e.sphere.offset)?r:[0,0,0]),radius:null!=(o=e.sphere.radius)?o:0,inside:null!=(a=e.sphere.inside)&&a});if(e.capsule)return this._importCapsuleCollider(M,{offset:new l.Pa4().fromArray(null!=(s=e.capsule.offset)?s:[0,0,0]),radius:null!=(u=e.capsule.radius)?u:0,tail:new l.Pa4().fromArray(null!=(h=e.capsule.tail)?h:[0,0,0]),inside:null!=(c=e.capsule.inside)&&c});if(e.plane)return this._importPlaneCollider(M,{offset:new l.Pa4().fromArray(null!=(p=e.plane.offset)?p:[0,0,0]),normal:new l.Pa4().fromArray(null!=(m=e.plane.normal)?m:[0,0,1])})}else console.warn("VRMSpringBoneLoaderPlugin: Unknown ".concat(t5,' specVersion "').concat(t,'". Fallbacking to the ').concat(e.EXTENSION_NAME," definition"))}if(y.sphere)return this._importSphereCollider(M,{offset:new l.Pa4().fromArray(null!=(f=y.sphere.offset)?f:[0,0,0]),radius:null!=(g=y.sphere.radius)?g:0,inside:!1});if(y.capsule)return this._importCapsuleCollider(M,{offset:new l.Pa4().fromArray(null!=(_=y.capsule.offset)?_:[0,0,0]),radius:null!=(v=y.capsule.radius)?v:0,tail:new l.Pa4().fromArray(null!=(x=y.capsule.tail)?x:[0,0,0]),inside:!1});throw Error("VRMSpringBoneLoaderPlugin: The collider #".concat(n," has no valid shape"))}),m=null==(o=h.colliderGroups)?void 0:o.map((e,t)=>{var n;return{colliders:(null!=(n=e.colliders)?n:[]).map(e=>{let n=null==p?void 0:p[e];if(null==n)throw Error("VRMSpringBoneLoaderPlugin: The colliderGroup #".concat(t," attempted to use a collider #").concat(e," but not found"));return n}),name:e.name}});return null==(a=h.springs)||a.forEach((e,t)=>{var n;let i=e.joints,r=null==(n=e.colliderGroups)?void 0:n.map(e=>{let n=null==m?void 0:m[e];if(null==n)throw Error("VRMSpringBoneLoaderPlugin: The spring #".concat(t," attempted to use a colliderGroup ").concat(e," but not found"));return n}),o=null!=e.center?d[e.center]:void 0,a;i.forEach(e=>{if(a){let t=d[a.node],n=d[e.node],i={hitRadius:a.hitRadius,dragForce:a.dragForce,gravityPower:a.gravityPower,stiffness:a.stiffness,gravityDir:null!=a.gravityDir?new l.Pa4().fromArray(a.gravityDir):void 0},s=this._importJoint(t,n,i,r);o&&(s.center=o),u.addJoint(s)}a=e})}),u.setInitState(),u})}_v0Import(e){return tE(this,null,function*(){var t,n,i;let r=e.parser.json;if(!((null==(t=r.extensionsUsed)?void 0:t.indexOf("VRM"))!==-1))return null;let o=null==(n=r.extensions)?void 0:n.VRM,a=null==o?void 0:o.secondaryAnimation;if(!a)return null;let s=null==a?void 0:a.boneGroups;if(!s)return null;let u=new t4,d=yield e.parser.getDependencies("node"),h=null==(i=a.colliderGroups)?void 0:i.map(e=>{var t;let n=d[e.node];return{colliders:(null!=(t=e.colliders)?t:[]).map((e,t)=>{var i,r,o;let a=new l.Pa4(0,0,0);return e.offset&&a.set(null!=(i=e.offset.x)?i:0,null!=(r=e.offset.y)?r:0,e.offset.z?-e.offset.z:0),this._importSphereCollider(n,{offset:a,radius:null!=(o=e.radius)?o:0,inside:!1})})}});return null==s||s.forEach((e,t)=>{let n=e.bones;n&&n.forEach(n=>{var i,r,o,a;let s=d[n],c=new l.Pa4;e.gravityDir?c.set(null!=(i=e.gravityDir.x)?i:0,null!=(r=e.gravityDir.y)?r:0,null!=(o=e.gravityDir.z)?o:0):c.set(0,-1,0);let p=null!=e.center?d[e.center]:void 0,m={hitRadius:e.hitRadius,dragForce:e.dragForce,gravityPower:e.gravityPower,stiffness:e.stiffiness,gravityDir:c},f=null==(a=e.colliderGroups)?void 0:a.map(e=>{let n=null==h?void 0:h[e];if(null==n)throw Error("VRMSpringBoneLoaderPlugin: The spring #".concat(t," attempted to use a colliderGroup ").concat(e," but not found"));return n});s.traverse(e=>{var t;let n=null!=(t=e.children[0])?t:null,i=this._importJoint(e,n,m,f);p&&(i.center=p),u.addJoint(i)})})}),e.scene.updateMatrixWorld(),u.setInitState(),u})}_importJoint(e,t,n,i){let r=new t2(e,t,n,i);if(this.jointHelperRoot){let e=new tk(r);this.jointHelperRoot.add(e),e.renderOrder=this.jointHelperRoot.renderOrder}return r}_importSphereCollider(e,t){let n=new tW(new tN(t));if(e.add(n),this.colliderHelperRoot){let e=new tH(n);this.colliderHelperRoot.add(e),e.renderOrder=this.colliderHelperRoot.renderOrder}return n}_importCapsuleCollider(e,t){let n=new tW(new tb(t));if(e.add(n),this.colliderHelperRoot){let e=new tH(n);this.colliderHelperRoot.add(e),e.renderOrder=this.colliderHelperRoot.renderOrder}return n}_importPlaneCollider(e,t){let n=new tW(new tC(t));if(e.add(n),this.colliderHelperRoot){let e=new tH(n);this.colliderHelperRoot.add(e),e.renderOrder=this.colliderHelperRoot.renderOrder}return n}constructor(e,t){var n;this.parser=e,this.jointHelperRoot=null==t?void 0:t.jointHelperRoot,this.colliderHelperRoot=null==t?void 0:t.colliderHelperRoot,this.useExtendedColliders=null==(n=null==t?void 0:t.useExtendedColliders)||n}};t9.EXTENSION_NAME="VRMC_springBone";var t8=class{get name(){return"VRMLoaderPlugin"}beforeRoot(){return c(this,null,function*(){yield this.materialsV0CompatPlugin.beforeRoot(),yield this.mtoonMaterialPlugin.beforeRoot()})}loadMesh(e){return c(this,null,function*(){return yield this.mtoonMaterialPlugin.loadMesh(e)})}getMaterialType(e){let t=this.mtoonMaterialPlugin.getMaterialType(e);return null!=t?t:null}extendMaterialParams(e,t){return c(this,null,function*(){yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(e,t),yield this.mtoonMaterialPlugin.extendMaterialParams(e,t)})}afterRoot(e){return c(this,null,function*(){yield this.metaPlugin.afterRoot(e),yield this.humanoidPlugin.afterRoot(e),yield this.expressionPlugin.afterRoot(e),yield this.lookAtPlugin.afterRoot(e),yield this.firstPersonPlugin.afterRoot(e),yield this.springBonePlugin.afterRoot(e),yield this.nodeConstraintPlugin.afterRoot(e),yield this.mtoonMaterialPlugin.afterRoot(e);let t=e.userData.vrmMeta,n=e.userData.vrmHumanoid;if(t&&n){let i=new eU({scene:e.scene,expressionManager:e.userData.vrmExpressionManager,firstPerson:e.userData.vrmFirstPerson,humanoid:n,lookAt:e.userData.vrmLookAt,meta:t,materials:e.userData.vrmMToonMaterials,springBoneManager:e.userData.vrmSpringBoneManager,nodeConstraintManager:e.userData.vrmNodeConstraintManager});e.userData.vrm=i}})}constructor(e,t){var n,i,r,o,a,s,l,u,d,h;this.parser=e;let c=null==t?void 0:t.helperRoot,p=null==t?void 0:t.autoUpdateHumanBones;this.expressionPlugin=null!=(n=null==t?void 0:t.expressionPlugin)?n:new A(e),this.firstPersonPlugin=null!=(i=null==t?void 0:t.firstPersonPlugin)?i:new I(e),this.humanoidPlugin=null!=(r=null==t?void 0:t.humanoidPlugin)?r:new Q(e,{helperRoot:c,autoUpdateHumanBones:p}),this.lookAtPlugin=null!=(o=null==t?void 0:t.lookAtPlugin)?o:new eL(e,{helperRoot:c}),this.metaPlugin=null!=(a=null==t?void 0:t.metaPlugin)?a:new eC(e),this.mtoonMaterialPlugin=null!=(s=null==t?void 0:t.mtoonMaterialPlugin)?s:new eq(e),this.materialsHDREmissiveMultiplierPlugin=null!=(l=null==t?void 0:t.materialsHDREmissiveMultiplierPlugin)?l:new eJ(e),this.materialsV0CompatPlugin=null!=(u=null==t?void 0:t.materialsV0CompatPlugin)?u:new e8(e),this.springBonePlugin=null!=(d=null==t?void 0:t.springBonePlugin)?d:new t9(e,{colliderHelperRoot:c,jointHelperRoot:c}),this.nodeConstraintPlugin=null!=(h=null==t?void 0:t.nodeConstraintPlugin)?h:new tP(e,{helperRoot:c})}};function ne(e){if(Object.values(e).forEach(e=>{null!=e&&e.isTexture&&e.dispose()}),e.isShaderMaterial){let t=e.uniforms;t&&Object.values(t).forEach(e=>{let t=e.value;null!=t&&t.isTexture&&t.dispose()})}e.dispose()}function nt(e){let t=e.geometry;t&&t.dispose();let n=e.skeleton;n&&n.dispose();let i=e.material;i&&(Array.isArray(i)?i.forEach(e=>ne(e)):i&&ne(i))}var nn=class{constructor(){}};nn.combineSkeletons=function(e){let t=new Set,n=new Map;e.traverse(e=>{if("SkinnedMesh"!==e.type)return;let i=n.get(e.geometry);i?t.delete(i):(n.set(e.geometry,e),t.add(e))});let i=[];for(let{bones:e,boneInverses:n,meshes:r}of(t.forEach(e=>{let t=e.skeleton,n=i.find(e=>t.bones.every((n,i)=>{let r=e.bones.indexOf(n);return -1===r||function(e,t,n){if(n=n||1e-4,e.elements.length!=t.elements.length)return!1;for(let i=0,r=e.elements.length;i<r;i++)if(Math.abs(e.elements[i]-t.elements[i])>n)return!1;return!0}(t.boneInverses[i],e.boneInverses[r])}));n||(n={bones:[],boneInverses:[],meshes:[]},i.push(n)),n.meshes.push(e);let r=t.bones.map(e=>n.bones.indexOf(e)),o=e.geometry,a=o.getAttribute("skinIndex"),s=o.getAttribute("skinWeight");for(let e=0;e<a.count;e++)for(let i=0;i<a.itemSize;i++){if(0===s.getComponent(e,i))continue;let o=a.getComponent(e,i);-1===r[o]&&(r[o]=n.bones.length,n.bones.push(t.bones[o]),n.boneInverses.push(t.boneInverses[o])),a.setComponent(e,i,r[o])}a.needsUpdate=!0}),i)){let t=new l.OdW(e,n);r.forEach(e=>e.bind(t,new l.yGw))}},nn.deepDispose=function(e){e.traverse(nt)},nn.removeUnnecessaryJoints=function(e,t){var n;console.warn("VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version.");let i=null!=(n=null==t?void 0:t.experimentalSameBoneCounts)&&n,r=[];e.traverse(e=>{"SkinnedMesh"===e.type&&r.push(e)});let o=new Map,a=0;for(let e of r){let t=e.geometry.getAttribute("skinIndex"),n=[],i=[],r={};for(let o=0;o<t.count;o++)for(let a=0;a<t.itemSize;a++){let s=t.getComponent(o,a);null==r[s]&&(r[s]=n.length,n.push(e.skeleton.bones[s]),i.push(e.skeleton.boneInverses[s])),t.setComponent(o,a,r[s])}t.needsUpdate=!0,o.set(e,{bones:n,boneInverses:i}),a=Math.max(a,n.length)}for(let e of r){let{bones:t,boneInverses:n}=o.get(e);if(i)for(let e=t.length;e<a;e++)t[e]=t[0],n[e]=n[0];let r=new l.OdW(t,n);e.bind(r,new l.yGw)}},nn.removeUnnecessaryVertices=function(e){let t=new Map;e.traverse(e=>{var n,i,r,o;if(!e.isMesh)return;let a=e.geometry,s=a.index;if(null==s)return;let u=t.get(a);if(null!=u){e.geometry=u;return}let d=Object.values(a.attributes)[0].count,h=Array(d),c=0,p=s.array;for(let e=0;e<p.length;e++){let t=p[e];h[t]||(h[t]=!0,c++)}if(c===d)return;let m=[],f=[],g=0;for(let e=0;e<h.length;e++)if(h[e]){let t=g++;m[e]=t,f[t]=e}let _=new l.u9r;_.name=a.name,_.morphTargetsRelative=a.morphTargetsRelative,a.groups.forEach(e=>{_.addGroup(e.start,e.count,e.materialIndex)}),_.boundingBox=null!=(i=null==(n=a.boundingBox)?void 0:n.clone())?i:null,_.boundingSphere=null!=(o=null==(r=a.boundingSphere)?void 0:r.clone())?o:null,_.setDrawRange(a.drawRange.start,a.drawRange.count),_.userData=a.userData,t.set(a,_);{let e=s.array,t=new e.constructor(e.length);for(let n=0;n<e.length;n++){let i=m[e[n]];t[n]=i}_.setIndex(new l.TlE(t,1,!1))}Object.keys(a.attributes).forEach(e=>{let t=a.attributes[e];if(t.isInterleavedBufferAttribute)throw Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");let n=t.array,{itemSize:i,normalized:r}=t,o=new n.constructor(f.length*i);f.forEach((e,t)=>{for(let r=0;r<i;r++)o[t*i+r]=n[e*i+r]}),_.setAttribute(e,new l.TlE(o,i,r))});let v=!0;Object.keys(a.morphAttributes).forEach(e=>{_.morphAttributes[e]=[];let t=a.morphAttributes[e];for(let n=0;n<t.length;n++){let i=t[n];if(i.isInterleavedBufferAttribute)throw Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");let r=i.array,{itemSize:o,normalized:a}=i,s=new r.constructor(f.length*o);f.forEach((e,t)=>{for(let n=0;n<o;n++)s[t*o+n]=r[e*o+n]}),v=v&&s.every(e=>0===e),_.morphAttributes[e][n]=new l.TlE(s,o,a)}}),v&&(_.morphAttributes={}),e.geometry=_}),Array.from(t.keys()).forEach(e=>{e.dispose()})},nn.rotateVRM0=function(e){var t;(null==(t=e.meta)?void 0:t.metaVersion)==="0"&&(e.scene.rotation.y=Math.PI)};var ni=n(96111);function nr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;return isNaN(e)?e:Array(t).fill(e)}function no(e){let t={material:"Physical",color:1136127,texture:{wrapping:"Repeat"}},n=e?"string"==typeof e?document.querySelector(e):e:document.body,i=new l.xsS,r=new l.cPb(75,window.innerWidth/window.innerHeight,.1,1e3),o=new u.WebGLRenderer({antialias:!0,alpha:!0});o.shadowMap.enabled=!0,o.setPixelRatio(window.devicePixelRatio);let a=new d.z(r,o.domElement);a.enableDamping=!0,a.dampingFactor=.25,a.disconnect();let s=n===document.body?window:n;s===window?(n.style.margin=0,o.setSize(s.innerWidth,s.innerHeight)):(o.setSize(s.scrollWidth,s.scrollHeight),r.aspect=s.scrollWidth/s.scrollHeight,r.updateProjectionMatrix()),n.appendChild(o.domElement),s.addEventListener("resize",e=>{s===window?(o.setSize(s.innerWidth,s.innerHeight),r.aspect=s.innerWidth/s.innerHeight):(o.setSize(s.scrollWidth,s.scrollHeight),r.aspect=s.scrollWidth/s.scrollHeight),r.updateProjectionMatrix()}),s!==window&&window.addEventListener("resize",e=>{o.setSize(s.scrollWidth,s.scrollHeight,!1),r.aspect=s.scrollWidth/s.scrollHeight,r.updateProjectionMatrix()}),o.domElement.style.aspectRatio=o.domElement.width/o.domElement.height,o.domElement.style.width="100%",o.domElement.style.height="auto";let c={object:function(e){let{size:n=[1,1,1],position:r=[0,0,0],rotation:o=[0,0,0],option:a={color:t.color},material:s=t.material,castShadow:d=!0,receiveShadow:h=!0,autoAdd:c=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},p=new l.Kj0(new u[e](...n),new u["Mesh".concat(s,"Material")]("Normal"===s?{}:a));return p.position.set(...r),p.rotation.set(...o),p.castShadow=d,p.receiveShadow=h,c&&i.add(p),p},cube:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return c.object("BoxGeometry",{...e,size:nr(e.size,3)})},sphere:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return c.object("SphereGeometry",{...e,size:nr(e.size,1)})},plane:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return c.object("PlaneGeometry",{...e,size:nr(e.size,2)})},ambientLight:function(){let{color:e=16777215,intensity:t=.5}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=new l.Mig(e,t);return i.add(n),n},pointLight:function(){let{color:e=16777215,intensity:t=1,distance:n=0,decay:r=2,position:o=[6,6,6],castShadow:a=!0,shadow:s={mapSize:[1024,1024]}}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},u=new l.cek(e,t,n,r);return u.position.set(...o),u.castShadow=a,a&&(u.shadow.mapSize=s.mapSize),i.add(u),u},directionalLight:function(){let{intensity:e=1,color:t=16777215,position:n=[10,10,10],castShadow:r=!0,shadow:o={mapSize:{width:1024,height:1024},camera:{left:-10,right:10,top:10,bottom:-10}}}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=new l.Ox3(t,e);return a.position.set(...n),a.castShadow=r,r&&(a.shadow.mapSize.width=o.mapSize.width,a.shadow.mapSize.height=o.mapSize.height,a.shadow.camera.left=o.camera.left,a.shadow.camera.right=o.camera.right,a.shadow.camera.top=o.camera.top,a.shadow.camera.bottom=o.camera.bottom),i.add(a),a}},p=new l.dpR;return{Default:t,scene:i,camera:r,renderer:o,controls:a,create:c,animate:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>{},t=new l.SUY;o.setAnimationLoop(function(){a.update();let n=t.getDelta();e({clock:t,delta:n}),o.render(i,r)})},color:function(e){return new l.Ilk(e)},THREE:u,helper:{grid:function(){let{size:e=10,divisions:t=10,colorCenterLine:n=4473924,colorGrid:r=8947848}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=new l.VLJ(e,t,n,r);return o.position.y=.005,i.add(o),o},axes:function(){let{size:e=10}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=new l.y8_(e);return t.position.y=.01,i.add(t),t}},load:{vrm:async function(e){let{position:t=[0,0,0],rotation:n=[0,0,0],scale:r=[1,1,1],autoAdd:o=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=new h.E;a.register(e=>new t8(e));let s=(await a.loadAsync(e)).userData.vrm;return nn.removeUnnecessaryVertices(s.scene),nn.combineSkeletons(s.scene),s.scene.traverse(e=>{e.frustumCulled=!1,e.isMesh&&(e.castShadow=!0)}),s.scene.position.set(...t),s.scene.rotation.set(...n),s.scene.scale.set(...r),o&&i.add(s.scene),s},background:e=>{new ni.x().load(e,e=>{e.mapping=l.dSO,i.background=e,i.environment=e})},texture:function(e){let{wrapS:n=t.texture.wrapping,wrapT:i=t.texture.wrapping,repeat:r=[1,1]}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=p.load(e);return o.wrapS=u["".concat(n,"Wrapping")],o.wrapT=u["".concat(i,"Wrapping")],o.repeat=new l.FM8(...r),o}}}}var na=n(2265);let ns=e=>{let t=(0,na.useRef)();return(0,na.useEffect)(()=>{let{camera:e,create:n,animate:i}=no(t.current);e.position.set(5,5,5),n.ambientLight(),n.directionalLight();let r=n.cube({size:3});i(e=>{let{clock:t}=e;r.rotation.x=t.getElapsedTime(),r.rotation.y=t.getElapsedTime()})},[]),(0,i.jsx)("div",{ref:t,...e})},nl=e=>{let t=(0,na.useRef)();return(0,na.useEffect)(()=>{let e;let{camera:n,create:i,animate:r,controls:o,helper:a,load:s}=no(t.current);o.autoRotate=!0,n.position.set(0,2,-2),o.target.set(0,1,0),i.ambientLight(),i.directionalLight({intensity:2,position:[10,10,-10]}),a.axes(),a.grid();let l=i.cube({size:.5,position:[1,1,0]});s.vrm("./model/sample.vrm").then(t=>{e=t}),r(t=>{let{clock:n,delta:i}=t;l.rotation.y+=i,l.rotation.x+=i,e&&(e.humanoid.getNormalizedBoneNode("leftUpperArm").rotation.z=Math.sin(n.getElapsedTime())*Math.PI*.25,e.update(i))})},[]),(0,i.jsx)("div",{ref:t,...e})},nu=e=>{let{worldControl:t,...n}=e,r=(0,na.useRef)(),o=(0,na.useRef)();return(0,na.useEffect)(()=>{o.current&&(t?o.current.connect():o.current.disconnect())},[t]),(0,na.useEffect)(()=>{let{camera:e,create:n,scene:i,renderer:a,controls:s,animate:l,load:u,THREE:d}=no(r.current),h=new d.TextureLoader;a.outputEncoding=d.sRGBEncoding,a.toneMapping=d.ACESFilmicToneMapping,o.current=s,t&&s.connect(),e.position.set(0,2,5),n.ambientLight({intensity:.5}),n.directionalLight({intensity:1}),u.background("./texture/hdr/symmetrical_garden_02_1k.hdr");let c={cube:{map:h.load("./texture/img/red_brick_diff_1k.jpg"),normalMap:h.load("./texture/img/red_brick_nor_gl_1k.jpg")},plane:{map:h.load("./texture/img/monastery_stone_floor_diff_1k.jpg"),normalMap:h.load("./texture/img/monastery_stone_floor_nor_gl_1k.jpg"),roughness:1}};c.cube.map.colorSpace=d.SRGBColorSpace,c.plane.map.colorSpace=d.SRGBColorSpace,c.plane.map.wrapS=d.RepeatWrapping,c.plane.map.wrapT=d.RepeatWrapping,c.plane.normalMap.wrapS=d.RepeatWrapping,c.plane.normalMap.wrapT=d.RepeatWrapping,c.plane.map.repeat.set(4,4),c.plane.normalMap.repeat.set(4,4),n.plane({size:10,position:[0,-1,0],rotation:[-Math.PI/2,0,0],option:c.plane}),n.cube({size:3,position:[0,.5,0],option:c.cube});let p=new d.Group;for(let e=0;e<4;e++)p.add(n[e%2==0?"cube":"sphere"]({size:1,position:[3*Math.sin(e*Math.PI*2/4),.5,3*Math.cos(e*Math.PI*2/4)],autoAdd:!1,option:{metalness:.5,roughness:0,color:16777215}}));i.add(p),n.cube({position:[0,2.5,0]}),l()},[]),(0,i.jsx)("div",{ref:r,...n})};var nd=n(70633),nh=n(93926),nc=n(26639),np=n(23575),nm=n(24402),nf=n(4670);function ng(e){let{children:t}=e;return(0,i.jsx)("span",{className:"fw-bold",children:t})}function n_(){let[e,t]=(0,na.useState)(!1);return(0,i.jsxs)("div",{children:[(0,i.jsx)("div",{className:"bg-body-tertiary pb-4",children:(0,i.jsxs)(r.default,{className:"py-3",children:[(0,i.jsx)("title",{children:"Home | easy-three"}),(0,i.jsx)("h1",{className:"headTitle mt-5 mb-4",children:"easy-three"}),(0,i.jsx)("div",{className:"text-center mb-4",children:(0,i.jsx)(nh.Z,{color:"blue",children:"v0.0.11"})}),(0,i.jsx)("div",{className:"headMessage",children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("span",{children:"Create stunning"}),(0,i.jsx)("span",{className:"impacted",children:"3D"}),(0,i.jsx)("span",{children:"with simple code."})]}),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)("span",{children:""}),(0,i.jsx)("span",{className:"impacted",children:"3D"}),(0,i.jsx)("span",{children:""})]})]})}),(0,i.jsxs)("div",{className:"text-center my-5",children:[(0,i.jsx)(o.Z,{variant:"primary",size:"lg",as:a.r,to:"/getting-started",children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Get Started"}),(0,i.jsx)(i.Fragment,{children:""})]})}),(0,i.jsx)(o.Z,{variant:"primary",size:"lg",className:"ms-3",as:a.r,to:"/reference",children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Reference"}),(0,i.jsx)(i.Fragment,{children:""})]})})]})]})}),(0,i.jsx)("div",{className:"py-0 mw-100 d-flex flex-column justify-content-center align-items-center",children:(0,i.jsxs)("div",{className:"position-relative d-inline-block mw-100",children:[(0,i.jsx)(nc.Z,{style:{position:"absolute",top:"10px",right:"10px"},defaultChecked:e,onChange:t,checkedChildren:"ON",unCheckedChildren:"OFF"}),(0,i.jsx)(nu,{worldControl:e,style:{width:"600px",aspectRatio:"6 / 4",maxWidth:"100%"}})]})}),(0,i.jsx)("div",{className:"bg-body-tertiary py-5",children:(0,i.jsxs)(r.default,{className:"mw-100",children:[(0,i.jsxs)("div",{className:"mb-5",children:[(0,i.jsx)("h4",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Three.js made simple"}),(0,i.jsx)(i.Fragment,{children:"Three.js "})]})}),(0,i.jsx)("p",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:["Three.js's powerful features, simplified for beginners.",(0,i.jsx)("br",{}),"easy-three supports everything from creating objects to animations and lighting setups."]}),(0,i.jsxs)(i.Fragment,{children:["Three.js",(0,i.jsx)("br",{}),"easy-three"]})]})})]}),(0,i.jsxs)("div",{className:"mb-5",children:[(0,i.jsx)("h4",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"No Installation Required"}),(0,i.jsx)(i.Fragment,{children:""})]})}),(0,i.jsx)("p",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:["No special software or configuration is required. You can start right away with ",(0,i.jsx)(ng,{children:"just a browser"}),".",(0,i.jsx)("br",{}),"It can also be used in environments where software installation is restricted, such as schools.",(0,i.jsx)("br",{})," A server is required when loading resources such as images (",(0,i.jsx)(a.r,{href:"/getting-started#server",children:"details here"}),")."," "]}),(0,i.jsxs)(i.Fragment,{children:["",(0,i.jsx)("br",{}),(0,i.jsx)(ng,{children:"Web"}),"",(0,i.jsx)("br",{}),"",(0,i.jsx)("br",{}),"  (",(0,i.jsx)(a.r,{to:{pathname:"/getting-started",hash:"#server"},children:""}),")"]})]})})]}),(0,i.jsxs)("div",{className:"d-flex justify-content-center justify-content-md-space-between flex-wrap flex-md-nowrap mw-100 mb-5",children:[(0,i.jsx)(ns,{style:{width:"500px",maxWidth:"100%",aspectRatio:"4 / 3",overflow:"hidden"}}),(0,i.jsxs)("div",{className:"w-100",style:{maxWidth:"600px"},children:[(0,i.jsx)("h4",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Simple Code"}),(0,i.jsx)(i.Fragment,{children:""})]})}),(0,i.jsx)("p",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:["You can create 3D objects with short code. ",(0,i.jsx)("br",{}),"Animations can also be set up easily."]}),(0,i.jsxs)(i.Fragment,{children:["3D",(0,i.jsx)("br",{}),""]})]})}),(0,i.jsx)(nd.Z,{children:"const { camera, create, animate } = init()\ncamera.position.set(5, 5, 5);\ncreate.ambientLight()\ncreate.directionalLight()\nconst cube = create.cube({ size: 6 })\nanimate(({ clock }) => {\n  cube.rotation.x = clock.getElapsedTime()\n  cube.rotation.y = clock.getElapsedTime()\n})\n"})]})]}),(0,i.jsxs)("div",{className:"d-flex justify-content-center justify-content-md-space-between flex-wrap flex-md-nowrap mw-100 mb-5",children:[(0,i.jsx)(nl,{style:{width:"500px",maxWidth:"100%",aspectRatio:"4 / 3",overflow:"hidden"}}),(0,i.jsxs)("div",{className:"w-100",style:{maxWidth:"600px"},children:[(0,i.jsx)("h4",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Quick and Easy Model Setup"}),(0,i.jsx)(i.Fragment,{children:""})]})}),(0,i.jsx)("p",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:["Displaying models like VRM is simple ( internally uses"," ",(0,i.jsx)("a",{href:"https://github.com/pixiv/three-vrm",children:"three-vrm"}),").",(0,i.jsx)("br",{}),"Mouse-based camera operation is also easy."]}),(0,i.jsxs)(i.Fragment,{children:["VRM ("," ",(0,i.jsx)("a",{href:"https://github.com/pixiv/three-vrm",children:"three-vrm"})," ",")",(0,i.jsx)("br",{}),""]})]})}),(0,i.jsx)(nd.Z,{children:'const { camera, create, animate, controls, helper, load } = init();\n\ncontrols.connect()\ncontrols.autoRotate = true\ncamera.position.set(0, 2, -2)\ncontrols.target.set(0, 1, 0)\ncreate.ambientLight()\ncreate.directionalLight({ intensity: 2, position: [10, 10, -10] })\nhelper.axes();\nhelper.grid();\nconst cube = create.cube({ size: 0.5, position: [1, 1, 0] })\nlet model;\nload.vrm("./model/sample.vrm").then(m => {\n  model = m\n})\nanimate(({ clock, delta }) => {\n  cube.rotation.y += delta\n  cube.rotation.x += delta\n  if (model) {\n    model.humanoid.getNormalizedBoneNode("leftUpperArm").rotation.z = Math.sin(clock.getElapsedTime()) * Math.PI * 0.25\n    model.update(delta)\n  }\n})\n'})]})]}),(0,i.jsxs)("div",{className:"mb-5",children:[(0,i.jsx)("h4",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Can also be used with React"}),(0,i.jsx)(i.Fragment,{children:"React"})]})}),(0,i.jsx)("p",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsxs)(i.Fragment,{children:["You can also use it directly with React. ",(0,i.jsx)("br",{}),"Perfect for adding a touch of 3D to your web page."]}),(0,i.jsxs)(i.Fragment,{children:["React",(0,i.jsx)("br",{}),"Web"]})]})}),(0,i.jsx)(nd.Z,{children:"const Simple = (props) => {\n  const ref = useRef()\n  useEffect(() => {\n    const { camera, create, animate } = init(ref.current)\n    camera.position.set(5, 5, 5);\n    create.ambientLight()\n    create.directionalLight()\n    const cube = create.cube({ size: 3 })\n    animate(({ clock }) => {\n      cube.rotation.x = clock.getElapsedTime()\n      cube.rotation.y = clock.getElapsedTime()\n    })\n  }, [])\n  return (\n    <div ref={ref} {...props}></div>\n  )\n}\n"})]})]})}),(0,i.jsx)("div",{className:"pb-5",children:(0,i.jsxs)(r.default,{children:[(0,i.jsx)("h2",{children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Comparison with vanilla Three.js"}),(0,i.jsx)(i.Fragment,{children:"vanilla Three.js "})]})}),(0,i.jsxs)("div",{className:"text-center text-md-start",children:[(0,i.jsxs)("div",{className:"d-inline-block text-center",children:[(0,i.jsx)("div",{className:"mb-3",children:"easy-three"}),(0,i.jsx)(np.Z,{type:"dashboard",percent:~~(1100/31),strokeWidth:10})]}),(0,i.jsxs)("div",{className:"d-inline-block text-center ms-3",children:[(0,i.jsx)("div",{className:"mb-3",children:"vanilla Three.js"}),(0,i.jsx)(np.Z,{type:"dashboard",percent:100,strokeWidth:10,percentPosition:{align:"center",type:"inner"},strokeColor:"red",status:"normal"})]}),(0,i.jsx)("div",{className:"mt-3",children:(0,i.jsxs)(s.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"Compared to vanilla Three.js, the code is simplified and easier to understand."}),(0,i.jsx)(i.Fragment,{children:" Three.js "})]})})]}),(0,i.jsxs)(nm.Z,{xs:1,lg:2,children:[(0,i.jsx)(nf.Z,{children:(0,i.jsx)(nd.Z,{showLineNumbers:!0,filename:"easy-three",children:'import { init } from "../dist/easy-three.js";\nconst { camera, create, controls, animate } = init()\n\n// camera settings\ncamera.position.set(-2, 2, 2)\n\n// use OrbitControls\ncontrols.connect()\n\n// add lights\ncreate.ambientLight()\ncreate.directionalLight()\n\n// add cube\nconst cube = create.cube()\n\n// animation\nanimate(({delta}) => {\n  cube.rotation.x += delta\n  cube.rotation.y += delta\n})'})}),(0,i.jsx)(nf.Z,{children:(0,i.jsx)(nd.Z,{showLineNumbers:!0,filename:"vanilla Three.js",children:'import * as THREE from "three";\nimport { OrbitControls } from "three/addons/controls/OrbitControls.js";\nconst scene = new THREE.Scene();\nconst renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })\nrenderer.setSize(window.innerWidth, window.innerHeight)\ndocument.body.appendChild(renderer.domElement)\nrenderer.shadowMap.enabled = true\nrenderer.setPixelRatio(window.devicePixelRatio)\n\n// camera settings\nconst camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)\ncamera.position.set(-2, 2, 2)\n\n// use OrbitControls\nconst controls = new OrbitControls(camera, renderer.domElement)\n\n// add lights\nconst ambientLight = new THREE.AmbientLight(0xffffff, 0.5)\nscene.add(ambientLight)\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 1)\ndirectionalLight.position.set(5, 5, 5)\nscene.add(directionalLight)\n\n// add cube\nconst box = new THREE.Mesh(\n  new THREE.BoxGeometry(1, 1, 1),\n  new THREE.MeshStandardMaterial({ color: 0x1155ff })\n)\nscene.add(box)\n\n// animation\nconst clock = new THREE.Clock()\nfunction animate() {\n  controls.update()\n  const delta = clock.getDelta()\n  box.rotation.x += delta\n  box.rotation.y += delta\n  renderer.render(scene, camera)\n}\nrenderer.setAnimationLoop(animate)'})})]})]})})]})}},56810:function(e,t,n){"use strict";n.d(t,{r:function(){return o}});var i=n(57437),r=n(27648);function o(e){let{href:t="",locale:n="/easy-three",children:o,...a}=e;return(0,i.jsx)(r.default,{...a,href:t,locale:n,children:o})}},70633:function(e,t,n){"use strict";n.d(t,{Z:function(){return h}});var i=n(57437),r=n(34814),o=n(61819),a=n(14301),s=n(11140),l=n(75471),u=n(28370),d=n(29527);function h(e){let{language:t="javascript",filename:n,className:h="",style:c={},showLineNumbers:p=!1,children:m}=e;return(0,i.jsxs)("div",{className:"my-3 ".concat(h),style:c,children:[n&&(0,i.jsxs)(r.Z,{justify:"space-between",className:"bg-secondary text-white px-3 py-2 rounded-top",style:{fontSize:"90%"},children:[n,(0,i.jsx)(o.ZP,{theme:{components:{Popover:{titleMinWidth:10}}},children:(0,i.jsx)(a.Z,{content:(0,i.jsx)("div",{children:(0,i.jsxs)(d.ZP,{children:[(0,i.jsx)(i.Fragment,{children:"copied to clipboard!"}),(0,i.jsx)(i.Fragment,{children:""})]})}),title:"",trigger:"click",children:(0,i.jsx)("div",{children:(0,i.jsx)(s.EZF,{className:"ms-auto",onClick:()=>{navigator.clipboard.writeText(m)}})})})})]}),(0,i.jsx)(l.Z,{showLineNumbers:p,language:t,style:u.Z,className:"".concat(n?"rounded-bottom":"rounded"," p-3"),children:m})]})}},29527:function(e,t,n){"use strict";n.d(t,{ZP:function(){return h},dr:function(){return u},kW:function(){return d}});var i=n(57437),r=n(61819),o=n(10968),a=n(2265);let s={lang:"en",setLang:()=>{}},l=(0,a.createContext)();function u(e){let{children:t}=e,[n,r]=(0,a.useState)(s);return(0,i.jsx)(l.Provider,{value:{config:n,setConfig:r},children:t})}function d(){let{config:e,setConfig:t}=(0,a.useContext)(l);return(0,a.useEffect)(()=>{let e=localStorage.getItem("config");e&&t(JSON.parse(e))},[]),(0,a.useEffect)(()=>{localStorage.setItem("config",JSON.stringify(e))},[e]),(0,i.jsx)(r.ZP,{theme:{components:{Segmented:{itemSelectedBg:"#1890ff"}}},children:(0,i.jsx)(o.Z,{className:"mx-1",size:"small",options:[{label:"Eng",value:"en"},{label:"",value:"ja"}],value:e.lang,onChange:n=>t({...e,lang:n})})})}function h(e){var t;let{children:n}=e,{config:r}=(0,a.useContext)(l);return(0,i.jsx)(i.Fragment,{children:"en"===r.lang?n[0]:null!==(t=n[1])&&void 0!==t?t:n[0]})}}},function(e){e.O(0,[779,689,870,351,972,777,146,781,971,117,744],function(){return e(e.s=67279)}),_N_E=e.O()}]);